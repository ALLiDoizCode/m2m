<!-- Powered by BMAD™ Core -->

# Story 8.4: Smart Contract Development - Channel Closure and Settlement

## Status

Done

## Story

**As a** smart contract developer,
**I want** channel closure with challenge periods and dispute resolution,
**so that** participants can exit channels unilaterally with protection against stale state submission.

## Acceptance Criteria

1. `closeChannel(bytes32 channelId, BalanceProof memory balanceProof, bytes memory signature)` function implemented
2. Close function validates balance proof signature using EIP-712 typed structured data
3. Close function records closing participant, balance proof, and current block timestamp
4. Challenge period starts on channel close (duration = `settlementTimeout` from channel creation)
5. `updateNonClosingBalanceProof()` allows counterparty to submit newer state during challenge
6. Newer state validated by comparing nonces (must be strictly greater)
7. `settleChannel(bytes32 channelId)` function distributes final balances after challenge period
8. Settlement calculates final balances: `deposit - transferred_to_counterparty`
9. Settlement transfers tokens to both participants using SafeERC20
10. Unit tests verify cooperative close, unilateral close, challenge submission, and final settlement

## Tasks / Subtasks

**Task Execution Strategy:** Story 8.4 implements channel closure and settlement logic for the TokenNetwork contract. Story 8.3 implemented channel opening and deposits. Story 8.4 adds the ability to close channels (either cooperatively or unilaterally), challenge stale states during a challenge period, and settle final balances on-chain. This completes the core payment channel lifecycle.

- [ ] Task 1: Implement BalanceProof Struct and EIP-712 Domain (AC: 1, 2)
  - [ ] Define BalanceProof struct
    - [ ] File location: `packages/contracts/src/TokenNetwork.sol`
    - [ ] Struct fields:
      ```solidity
      struct BalanceProof {
          bytes32 channelId;      // Channel identifier
          uint256 nonce;          // Monotonically increasing state counter
          uint256 transferredAmount;  // Cumulative amount sent to counterparty
          uint256 lockedAmount;       // Amount in pending conditional transfers (HTLC)
          bytes32 locksRoot;          // Merkle root of hash-locked transfers
      }
      ```
    - [ ] Purpose: Off-chain state representation for channel closure
    - [ ] Source: Epic 8 Story 8.4 AC1, Raiden Network balance proof pattern
  - [ ] Define EIP-712 domain separator
    - [ ] Import OpenZeppelin EIP712: `import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";`
    - [ ] TokenNetwork inherits EIP712: `contract TokenNetwork is ReentrancyGuard, EIP712 {}`
    - [ ] Constructor sets domain: `EIP712("TokenNetwork", "1") {}`
    - [ ] Domain includes: contract name, version, chainId, verifyingContract
    - [ ] Purpose: Prevent signature replay across chains and contracts
    - [ ] Source: Epic 8 Story 8.4 EIP-712 Signature Scheme, OpenZeppelin v5.x EIP712
  - [ ] Define BALANCE_PROOF_TYPEHASH constant
    - [ ] Constant:
      ```solidity
      bytes32 private constant BALANCE_PROOF_TYPEHASH = keccak256(
          "BalanceProof(bytes32 channelId,uint256 nonce,uint256 transferredAmount,uint256 lockedAmount,bytes32 locksRoot)"
      );
      ```
    - [ ] Purpose: EIP-712 type hash for balance proof verification
    - [ ] Source: Epic 8 Story 8.4 Balance Proof Verification
  - [ ] Add NatSpec documentation for BalanceProof struct and constants
    - [ ] Document each struct field's purpose
    - [ ] Document EIP-712 domain parameters
    - [ ] Source: Story 8.3 NatSpec patterns

- [ ] Task 2: Implement closeChannel Function (AC: 1, 2, 3, 4)
  - [ ] Function signature
    - [ ] `function closeChannel(bytes32 channelId, BalanceProof memory balanceProof, bytes memory signature) external nonReentrant`
    - [ ] Parameters: channelId, balance proof from non-closing participant, signature
    - [ ] Caller becomes "closing participant"
    - [ ] Source: Epic 8 Story 8.4 AC1
  - [ ] Validate channel exists and is open
    - [ ] Get channel: `Channel storage channel = channels[channelId];`
    - [ ] Check state: `if (channel.state != ChannelState.Opened) revert InvalidChannelState();`
    - [ ] Source: Story 8.3 state validation pattern
  - [ ] Validate caller is a participant
    - [ ] Check: `if (msg.sender != channel.participant1 && msg.sender != channel.participant2) revert InvalidParticipant();`
    - [ ] Source: Security validation
  - [ ] Identify non-closing participant
    - [ ] Calculate: `address nonClosingParticipant = msg.sender == channel.participant1 ? channel.participant2 : channel.participant1;`
    - [ ] Purpose: Determine whose balance proof signature to verify
    - [ ] Source: Raiden Network channel closure pattern
  - [ ] Validate balance proof signature (AC2)
    - [ ] Validate balance proof channelId matches: `if (balanceProof.channelId != channelId) revert InvalidBalanceProof();`
    - [ ] Compute EIP-712 struct hash:
      ```solidity
      bytes32 structHash = keccak256(abi.encode(
          BALANCE_PROOF_TYPEHASH,
          balanceProof.channelId,
          balanceProof.nonce,
          balanceProof.transferredAmount,
          balanceProof.lockedAmount,
          balanceProof.locksRoot
      ));
      ```
    - [ ] Compute EIP-712 digest: `bytes32 digest = _hashTypedDataV4(structHash);`
    - [ ] Recover signer: `address recovered = ECDSA.recover(digest, signature);`
    - [ ] Validate signer: `if (recovered != nonClosingParticipant) revert InvalidSignature();`
    - [ ] Import OpenZeppelin ECDSA: `import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";`
    - [ ] Source: Epic 8 Story 8.4 Balance Proof Verification, OpenZeppelin v5.x ECDSA
  - [ ] Validate nonce is greater than stored nonce
    - [ ] Get stored nonce: `uint256 storedNonce = participants[channelId][nonClosingParticipant].nonce;`
    - [ ] Check: `if (balanceProof.nonce <= storedNonce) revert InvalidNonce();`
    - [ ] Purpose: Prevent replay of old balance proofs
    - [ ] Source: Epic 8 Story 8.4 Security Considerations - Stale State Protection
  - [ ] Record closing participant and balance proof (AC3)
    - [ ] Set closer flag: `participants[channelId][msg.sender].isCloser = true;`
    - [ ] Update non-closing participant state:
      ```solidity
      participants[channelId][nonClosingParticipant].nonce = balanceProof.nonce;
      participants[channelId][nonClosingParticipant].balanceHash = keccak256(abi.encodePacked(
          balanceProof.transferredAmount,
          balanceProof.lockedAmount,
          balanceProof.locksRoot
      ));
      ```
    - [ ] Source: Raiden Network balance proof storage pattern
  - [ ] Update channel state to Closed and record timestamp (AC4)
    - [ ] Set state: `channel.state = ChannelState.Closed;`
    - [ ] Record timestamp: `channel.closedAt = block.timestamp;`
    - [ ] Purpose: Start challenge period countdown
    - [ ] Source: Epic 8 Story 8.4 AC4, Story 8.3 Channel struct
  - [ ] Emit ChannelClosed event
    - [ ] Event definition (from Story 8.3):
      ```solidity
      event ChannelClosed(
          bytes32 indexed channelId,
          address indexed closingParticipant,
          uint256 nonce,
          bytes32 balanceHash
      );
      ```
    - [ ] Emit: `emit ChannelClosed(channelId, msg.sender, balanceProof.nonce, balanceHash);`
    - [ ] Source: Epic 8 Story 8.3 AC9 event pattern
  - [ ] Add NatSpec documentation
    - [ ] Document parameters, return values, and behavior
    - [ ] Explain EIP-712 signature verification
    - [ ] Document challenge period start
    - [ ] Source: Story 8.3 NatSpec standards

- [ ] Task 3: Implement updateNonClosingBalanceProof Function (AC: 5, 6)
  - [ ] Function signature
    - [ ] `function updateNonClosingBalanceProof(bytes32 channelId, BalanceProof memory balanceProof, bytes memory signature) external nonReentrant`
    - [ ] Purpose: Non-closing participant can submit newer balance proof during challenge period
    - [ ] Caller must be non-closing participant
    - [ ] Source: Epic 8 Story 8.4 AC5
  - [ ] Validate channel is in Closed state
    - [ ] Get channel: `Channel storage channel = channels[channelId];`
    - [ ] Check state: `if (channel.state != ChannelState.Closed) revert InvalidChannelState();`
    - [ ] Source: Epic 8 Story 8.4 AC5
  - [ ] Validate caller is non-closing participant
    - [ ] Check: `if (participants[channelId][msg.sender].isCloser) revert CallerIsCloser();`
    - [ ] Check: `if (msg.sender != channel.participant1 && msg.sender != channel.participant2) revert InvalidParticipant();`
    - [ ] Source: Security validation
  - [ ] Validate challenge period has not expired
    - [ ] Check: `if (block.timestamp >= channel.closedAt + channel.settlementTimeout) revert ChallengePeriodExpired();`
    - [ ] Purpose: Only allow updates during challenge window
    - [ ] Source: Epic 8 Story 8.4 AC5
  - [ ] Identify closing participant
    - [ ] Calculate: `address closingParticipant = participants[channelId][channel.participant1].isCloser ? channel.participant1 : channel.participant2;`
    - [ ] Purpose: Verify signature from closing participant
    - [ ] Source: Challenge mechanism pattern
  - [ ] Validate balance proof signature (same as closeChannel)
    - [ ] Validate channelId matches
    - [ ] Compute EIP-712 struct hash and digest
    - [ ] Recover signer: `address recovered = ECDSA.recover(digest, signature);`
    - [ ] Validate signer: `if (recovered != closingParticipant) revert InvalidSignature();`
    - [ ] Source: Epic 8 Story 8.4 AC5, same verification as closeChannel
  - [ ] Validate nonce is strictly greater than stored nonce (AC6)
    - [ ] Get stored nonce: `uint256 storedNonce = participants[channelId][closingParticipant].nonce;`
    - [ ] Check: `if (balanceProof.nonce <= storedNonce) revert InvalidNonce();`
    - [ ] Purpose: Only accept newer state during challenge
    - [ ] Source: Epic 8 Story 8.4 AC6 - Monotonic nonces
  - [ ] Update closing participant state with newer balance proof
    - [ ] Update nonce: `participants[channelId][closingParticipant].nonce = balanceProof.nonce;`
    - [ ] Update balance hash:
      ```solidity
      participants[channelId][closingParticipant].balanceHash = keccak256(abi.encodePacked(
          balanceProof.transferredAmount,
          balanceProof.lockedAmount,
          balanceProof.locksRoot
      ));
      ```
    - [ ] Source: Raiden Network challenge mechanism
  - [ ] Emit NonClosingBalanceProofUpdated event
    - [ ] Event definition:
      ```solidity
      event NonClosingBalanceProofUpdated(
          bytes32 indexed channelId,
          address indexed participant,
          uint256 nonce,
          bytes32 balanceHash
      );
      ```
    - [ ] Emit: `emit NonClosingBalanceProofUpdated(channelId, msg.sender, balanceProof.nonce, balanceHash);`
    - [ ] Source: Epic 8 Story 8.3 AC9 event pattern
  - [ ] Add NatSpec documentation
    - [ ] Document challenge mechanism
    - [ ] Explain nonce validation
    - [ ] Document challenge period constraints
    - [ ] Source: Story 8.3 NatSpec standards

- [ ] Task 4: Implement settleChannel Function (AC: 7, 8, 9)
  - [ ] Function signature
    - [ ] `function settleChannel(bytes32 channelId) external nonReentrant`
    - [ ] Purpose: Distribute final balances after challenge period expires
    - [ ] Anyone can call (no access control, prevents griefing)
    - [ ] Source: Epic 8 Story 8.4 AC7
  - [ ] Validate channel is in Closed state
    - [ ] Get channel: `Channel storage channel = channels[channelId];`
    - [ ] Check state: `if (channel.state != ChannelState.Closed) revert InvalidChannelState();`
    - [ ] Source: Epic 8 Story 8.4 AC7
  - [ ] Validate challenge period has expired
    - [ ] Check: `if (block.timestamp < channel.closedAt + channel.settlementTimeout) revert SettlementTimeoutNotExpired();`
    - [ ] Purpose: Ensure challenge window has passed
    - [ ] Source: Epic 8 Story 8.4 AC7
  - [ ] Calculate final balances for both participants (AC8)
    - [ ] For each participant:

      ```solidity
      // Participant 1 final balance
      uint256 participant1Deposit = participants[channelId][channel.participant1].deposit;
      uint256 participant1Withdrawn = participants[channelId][channel.participant1].withdrawnAmount;
      uint256 participant1Transferred = extractTransferredAmount(
          participants[channelId][channel.participant1].balanceHash
      );

      uint256 participant1FinalBalance = participant1Deposit - participant1Withdrawn - participant1Transferred;

      // Participant 2 receives what participant1 transferred
      uint256 participant2Deposit = participants[channelId][channel.participant2].deposit;
      uint256 participant2Withdrawn = participants[channelId][channel.participant2].withdrawnAmount;
      uint256 participant2Transferred = extractTransferredAmount(
          participants[channelId][channel.participant2].balanceHash
      );

      uint256 participant2FinalBalance = participant2Deposit - participant2Withdrawn - participant2Transferred + participant1Transferred;
      ```

    - [ ] Note: Locked amounts (HTLCs) treated as zero for Story 8.4 (no HTLC support yet)
    - [ ] Source: Epic 8 Story 8.4 AC8 - Balance calculation formula

  - [ ] Helper function: extractTransferredAmount
    - [ ] Function: `function extractTransferredAmount(bytes32 balanceHash) internal pure returns (uint256)`
    - [ ] Purpose: Extract transferredAmount from stored balanceHash
    - [ ] Implementation: Requires storing transferredAmount separately or using struct instead of hash
    - [ ] **CRITICAL DECISION:** Store transferredAmount directly in ParticipantState instead of balanceHash
    - [ ] Modify ParticipantState struct (Story 8.3) to include: `uint256 transferredAmount;`
    - [ ] Source: Simplification for Story 8.4 (no HTLC support yet, balanceHash not needed)
  - [ ] Transfer tokens to both participants using SafeERC20 (AC9)
    - [ ] Transfer to participant1:
      ```solidity
      if (participant1FinalBalance > 0) {
          IERC20(token).safeTransfer(channel.participant1, participant1FinalBalance);
      }
      ```
    - [ ] Transfer to participant2:
      ```solidity
      if (participant2FinalBalance > 0) {
          IERC20(token).safeTransfer(channel.participant2, participant2FinalBalance);
      }
      ```
    - [ ] Use SafeERC20.safeTransfer (not safeTransferFrom, contract owns tokens)
    - [ ] Source: Epic 8 Story 8.3 AC7 SafeERC20 requirement
  - [ ] Update channel state to Settled
    - [ ] Set state: `channel.state = ChannelState.Settled;`
    - [ ] Purpose: Prevent double settlement
    - [ ] Source: Epic 8 Story 8.3 AC6 ChannelState enum
  - [ ] Emit ChannelSettled event
    - [ ] Event definition:
      ```solidity
      event ChannelSettled(
          bytes32 indexed channelId,
          uint256 participant1Amount,
          uint256 participant2Amount
      );
      ```
    - [ ] Emit: `emit ChannelSettled(channelId, participant1FinalBalance, participant2FinalBalance);`
    - [ ] Source: Epic 8 Story 8.3 AC9 event pattern
  - [ ] Add NatSpec documentation
    - [ ] Document settlement finality
    - [ ] Explain balance calculation formula
    - [ ] Document SafeERC20 transfers
    - [ ] Source: Story 8.3 NatSpec standards

- [ ] Task 5: Add Custom Errors for Channel Closure (AC: 1-10)
  - [ ] Define custom errors for gas optimization
    - [ ] `error InvalidBalanceProof();` - Balance proof validation failed
    - [ ] `error InvalidSignature();` - Signature recovery failed or wrong signer
    - [ ] `error InvalidNonce();` - Nonce not greater than stored nonce
    - [ ] `error CallerIsCloser();` - updateNonClosingBalanceProof called by closer
    - [ ] `error ChallengePeriodExpired();` - Challenge period has ended
    - [ ] `error SettlementTimeoutNotExpired();` - Settlement called too early
    - [ ] Source: Story 8.3 custom errors pattern, Epic 8 Story 8.4 error cases

- [ ] Task 6: Update ParticipantState Struct for Closure Logic (AC: 1-10)
  - [ ] Modify ParticipantState struct in TokenNetwork.sol
    - [ ] Add field: `uint256 transferredAmount;` (replaces balanceHash for simplicity)
    - [ ] Remove field: `bytes32 balanceHash;` (defer to Story 8.5 for HTLC support)
    - [ ] Rationale: Story 8.4 focuses on basic closure without HTLCs
    - [ ] Source: Architecture simplification for MVP
  - [ ] Update closeChannel to store transferredAmount
    - [ ] Extract from balance proof: `participants[channelId][nonClosingParticipant].transferredAmount = balanceProof.transferredAmount;`
    - [ ] Source: Task 2 balance proof storage
  - [ ] Update updateNonClosingBalanceProof to store transferredAmount
    - [ ] Extract from balance proof: `participants[channelId][closingParticipant].transferredAmount = balanceProof.transferredAmount;`
    - [ ] Source: Task 3 balance proof update
  - [ ] Update settleChannel to use transferredAmount directly
    - [ ] Calculate balances using stored transferredAmount
    - [ ] Source: Task 4 settlement calculation

- [ ] Task 7: Create Foundry Unit Tests for Channel Closure and Settlement (AC: 10)
  - [ ] Expand test file `packages/contracts/test/TokenNetwork.t.sol`
    - [ ] File location: `packages/contracts/test/TokenNetwork.t.sol`
    - [ ] Solidity version: `pragma solidity ^0.8.20;`
    - [ ] Import contracts: `import "../src/TokenNetwork.sol";`, `import "./mocks/MockERC20.sol";`
    - [ ] Source: Story 8.3 Foundry test pattern
  - [ ] Helper function: createAndFundChannel
    - [ ] Function: `function createAndFundChannel(address participant1, address participant2, uint256 deposit1, uint256 deposit2) internal returns (bytes32)`
    - [ ] Opens channel and deposits for both participants
    - [ ] Returns channelId
    - [ ] Purpose: Reduce test boilerplate
    - [ ] Source: Test helper pattern
  - [ ] Helper function: signBalanceProof
    - [ ] Function: `function signBalanceProof(uint256 privateKey, bytes32 channelId, uint256 nonce, uint256 transferredAmount) internal view returns (bytes memory)`
    - [ ] Signs balance proof using EIP-712
    - [ ] Uses Foundry vm.sign for test signatures
    - [ ] Returns signature bytes
    - [ ] Source: Foundry test signature generation pattern
  - [ ] Test: testCloseChannel - Happy path channel closure
    - [ ] Setup: Open channel, deposit funds (alice 1000, bob 1000)
    - [ ] Create balance proof: alice transferred 250 to bob (nonce 1)
    - [ ] Sign balance proof with alice's private key
    - [ ] Bob calls closeChannel with alice's balance proof and signature
    - [ ] Assert: Channel state is Closed
    - [ ] Assert: Channel closedAt timestamp is block.timestamp
    - [ ] Assert: Bob is marked as closer (participants[channelId][bob].isCloser == true)
    - [ ] Assert: Alice's nonce updated to 1
    - [ ] Assert: Alice's transferredAmount updated to 250
    - [ ] Assert: ChannelClosed event emitted with correct parameters
    - [ ] Source: Epic 8 Story 8.4 AC1-4
  - [ ] Test: testCloseChannelRevertsOnInvalidState - State validation
    - [ ] Setup: Open channel, deposit funds, close channel
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.InvalidChannelState.selector)`
    - [ ] Call: closeChannel again (channel already Closed)
    - [ ] Source: Security validation
  - [ ] Test: testCloseChannelRevertsOnInvalidSignature - Signature validation
    - [ ] Setup: Open channel, deposit funds
    - [ ] Create balance proof: alice transferred 250 to bob
    - [ ] Sign with wrong private key (charlie's key, not alice's)
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.InvalidSignature.selector)`
    - [ ] Call: closeChannel with invalid signature
    - [ ] Source: Epic 8 Story 8.4 AC2 signature verification
  - [ ] Test: testCloseChannelRevertsOnStaleNonce - Nonce validation
    - [ ] Setup: Open channel, deposit funds
    - [ ] Manually set alice's nonce to 5 (simulate previous state)
    - [ ] Create balance proof with nonce 3 (stale)
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.InvalidNonce.selector)`
    - [ ] Call: closeChannel with stale balance proof
    - [ ] Source: Epic 8 Story 8.4 AC2 stale state protection
  - [ ] Test: testUpdateNonClosingBalanceProof - Happy path challenge
    - [ ] Setup: Open channel, deposit funds, bob closes with alice's state (nonce 1, transferred 250)
    - [ ] Create newer balance proof: alice transferred 500 (nonce 2)
    - [ ] Sign with alice's private key
    - [ ] Alice calls updateNonClosingBalanceProof with newer state
    - [ ] Assert: Alice's nonce updated to 2
    - [ ] Assert: Alice's transferredAmount updated to 500
    - [ ] Assert: NonClosingBalanceProofUpdated event emitted
    - [ ] Source: Epic 8 Story 8.4 AC5-6
  - [ ] Test: testUpdateNonClosingBalanceProofRevertsOnExpiredChallenge - Challenge period validation
    - [ ] Setup: Open channel, deposit funds, close channel
    - [ ] Fast forward time: `vm.warp(block.timestamp + settlementTimeout + 1)`
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.ChallengePeriodExpired.selector)`
    - [ ] Call: updateNonClosingBalanceProof after challenge period
    - [ ] Source: Epic 8 Story 8.4 AC5
  - [ ] Test: testUpdateNonClosingBalanceProofRevertsOnNonMonotonicNonce - Nonce validation
    - [ ] Setup: Open channel, deposit funds, close with nonce 5
    - [ ] Create balance proof with nonce 3 (not greater than 5)
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.InvalidNonce.selector)`
    - [ ] Call: updateNonClosingBalanceProof with non-monotonic nonce
    - [ ] Source: Epic 8 Story 8.4 AC6
  - [ ] Test: testSettleChannel - Happy path settlement
    - [ ] Setup: Open channel, alice deposits 1000, bob deposits 1000
    - [ ] Close channel: bob closes with alice's state (alice transferred 250 to bob, nonce 1)
    - [ ] Fast forward time past challenge period: `vm.warp(block.timestamp + settlementTimeout + 1)`
    - [ ] Record balances before settlement
    - [ ] Call: settleChannel(channelId)
    - [ ] Assert: Channel state is Settled
    - [ ] Assert: Alice received 750 tokens (1000 - 250 transferred)
    - [ ] Assert: Bob received 1250 tokens (1000 + 250 received)
    - [ ] Assert: TokenNetwork contract balance is 0
    - [ ] Assert: ChannelSettled event emitted with correct amounts
    - [ ] Source: Epic 8 Story 8.4 AC7-9
  - [ ] Test: testSettleChannelWithChallenge - Settlement after challenge
    - [ ] Setup: Open channel, alice deposits 1000, bob deposits 1000
    - [ ] Bob closes with alice's state (alice transferred 250, nonce 1)
    - [ ] Alice challenges with newer state (alice transferred 500, nonce 2)
    - [ ] Fast forward time past challenge period
    - [ ] Call: settleChannel(channelId)
    - [ ] Assert: Alice received 500 tokens (1000 - 500 transferred)
    - [ ] Assert: Bob received 1500 tokens (1000 + 500 received)
    - [ ] Purpose: Verify challenge updates are used in settlement
    - [ ] Source: Epic 8 Story 8.4 AC5-9
  - [ ] Test: testSettleChannelRevertsBeforeTimeout - Timeout validation
    - [ ] Setup: Open channel, deposit funds, close channel
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.SettlementTimeoutNotExpired.selector)`
    - [ ] Call: settleChannel immediately (before challenge period)
    - [ ] Source: Epic 8 Story 8.4 AC7
  - [ ] Test: testSettleChannelRevertsOnWrongState - State validation
    - [ ] Setup: Open channel, deposit funds (do not close)
    - [ ] Expect revert: `vm.expectRevert(TokenNetwork.InvalidChannelState.selector)`
    - [ ] Call: settleChannel on Opened channel
    - [ ] Source: Security validation
  - [ ] Test: testBilateralTransfers - Both participants transfer
    - [ ] Setup: Open channel, alice deposits 1000, bob deposits 1000
    - [ ] Close with alice's state: alice transferred 300 to bob (nonce 1)
    - [ ] Challenge with bob's state: bob transferred 200 to alice (nonce 1)
    - [ ] Fast forward and settle
    - [ ] Assert: Alice received 900 tokens (1000 - 300 transferred + 200 received)
    - [ ] Assert: Bob received 1100 tokens (1000 - 200 transferred + 300 received)
    - [ ] Purpose: Verify bilateral transfer logic
    - [ ] Source: Epic 8 Story 8.4 AC8 balance calculation
  - [ ] Run Foundry tests: `forge test`
    - [ ] Expected: All tests pass
    - [ ] Coverage: >90% for TokenNetwork.sol (including closure logic)
    - [ ] Source: Story 8.3 testing standards

- [ ] Task 8: Update Documentation (AC: 1-10)
  - [ ] Update smart contract development guide
    - [ ] File: `docs/guides/smart-contract-development.md`
    - [ ] Add "Channel Closure and Settlement" section
    - [ ] Explain closeChannel, updateNonClosingBalanceProof, settleChannel functions
    - [ ] Add EIP-712 signature generation examples
    - [ ] Document challenge period mechanism
    - [ ] Source: Story 8.3 documentation pattern
  - [ ] Update README.md
    - [ ] File: `README.md`
    - [ ] Update Smart Contract Development section
    - [ ] Add status: Story 8.4 completed (channel closure and settlement)
    - [ ] Source: Story 8.3 README updates

## Dev Notes

### Story Context

This is the **fourth story in Epic 8: EVM Payment Channels (Base L2)**. Epic 8 builds production-ready XRP-style payment channel smart contracts for EVM chains, deployed to Base L2 mainnet. Story 8.4 implements channel closure and settlement logic, completing the core payment channel lifecycle.

**Epic 8 Context:**

- **Story 8.1 (DONE)**: Foundry development environment setup
- **Story 8.2 (DONE)**: TokenNetworkRegistry factory contract implementation
- **Story 8.3 (DONE)**: TokenNetwork core contract (channel opening and deposits)
- **Story 8.4 (this story)**: Channel closure and settlement logic
- **Story 8.5**: Smart contract security hardening
- **Story 8.6**: Comprehensive testing and security audit
- **Story 8.7**: Off-chain payment channel SDK (TypeScript)
- **Story 8.8**: Settlement engine integration
- **Story 8.9**: Automated channel lifecycle management
- **Story 8.10**: Dashboard payment channel visualization

**Architectural Role:**

Story 8.4 **implements channel closure and settlement** for TokenNetwork contracts. Story 8.3 implemented channel opening and deposits. Story 8.4 adds the ability to:

1. **Close channels** with balance proofs (cooperative or unilateral)
2. **Challenge stale states** during challenge period
3. **Settle final balances** on-chain after challenge period expires

This completes the core payment channel lifecycle.

**Foundation from Story 8.3:**

Story 8.3 "Smart Contract Development - TokenNetwork Core" (DONE) provides:

- **Channel State Management:** Channel and ParticipantState structs, ChannelState enum
- **Channel Opening:** openChannel() function with participant validation
- **Deposit Functionality:** setTotalDeposit() with SafeERC20 and ReentrancyGuard
- **Test Infrastructure:** Foundry test patterns, MockERC20 token, 15 passing unit tests
- **100% Line Coverage:** Excellent test coverage baseline

Story 8.4 builds on this foundation by adding channel closure, challenge mechanism, and settlement distribution.

### Previous Story Insights

**Key Learnings from Story 8.3 (TokenNetwork Core):**

Story 8.3 implemented TokenNetwork channel opening and deposit functionality following Raiden Network architecture. Key patterns to continue:

1. **Solidity Version Consistency:**
   - All contracts use `pragma solidity ^0.8.20;`
   - Foundry configured with `solc_version = "0.8.20"` in foundry.toml
   - OpenZeppelin v5.5.0 installed (SafeERC20, ReentrancyGuard, EIP712, ECDSA)

2. **Contract Structure Standards:**
   - SPDX license headers: `// SPDX-License-Identifier: MIT`
   - PascalCase contract naming
   - NatSpec documentation for all public functions, events, errors
   - Custom errors for gas optimization (saves ~50 gas vs require strings)

3. **Testing Patterns:**
   - Test files: `TokenNetwork.t.sol` (Foundry convention)
   - Test contract: `contract TokenNetworkTest is Test {}`
   - setUp function deploys contracts before each test
   - Test naming: `function test<Functionality>() public {}`
   - Revert tests: `function test<Functionality>RevertsOn<Condition>() public {}`

4. **OpenZeppelin v5.x Patterns:**
   - ReentrancyGuard modifier: `nonReentrant` on external functions
   - SafeERC20: `using SafeERC20 for IERC20;` for safe token transfers
   - EIP712: Inherit for EIP-712 signature verification (new in Story 8.4)
   - ECDSA: Use ECDSA.recover() for signature recovery (new in Story 8.4)

5. **Security Best Practices:**
   - State validation before operations (e.g., channel must be Opened)
   - Input validation (zero address checks, participant validation)
   - Balance verification for fee-on-transfer tokens
   - Event emission for all state changes

**Apply to Story 8.4:**

- Inherit from EIP712 for domain separator: `contract TokenNetwork is ReentrancyGuard, EIP712 {}`
- Use OpenZeppelin ECDSA.recover() for signature verification
- Apply nonReentrant modifier to closeChannel, updateNonClosingBalanceProof, settleChannel
- Use SafeERC20.safeTransfer for settlement token distributions
- Follow custom errors pattern for gas optimization
- Maintain NatSpec documentation standards from Story 8.3
- Continue Foundry test patterns with helper functions for signature generation

**QA Review Insights from Story 8.3:**

Story 8.3 QA review (2026-01-09) rated implementation as EXCELLENT with 100/100 quality score. Key strengths:

- 100% line coverage (exceeded >90% requirement)
- 97.37% branch coverage
- Clean code following Raiden Network patterns
- Comprehensive NatSpec documentation
- Correct OpenZeppelin v5.x usage

Story 8.4 should maintain this quality standard.

### Architecture Context

**Channel Closure and Settlement Flow:**

[Source: Epic 8 Story 8.4 technical specification, Raiden Network architecture]

Story 8.4 implements the final stages of payment channel lifecycle: closure with challenge period and final settlement.

**Channel Lifecycle Flow (Story 8.4 Scope: Closure and Settlement):**

```
Story 8.3: Channel Opened and Funded
   ↓
1. Bob calls: tokenNetwork.closeChannel(channelId, aliceBalanceProof, aliceSignature)
   ↓
2. TokenNetwork validates: channel is Opened, bob is participant
   ↓
3. TokenNetwork verifies: aliceBalanceProof signature using EIP-712
   ↓
4. TokenNetwork validates: aliceBalanceProof.nonce > stored nonce (stale state protection)
   ↓
5. TokenNetwork records: bob is closer, alice's nonce and transferredAmount
   ↓
6. TokenNetwork updates: channel.state = Closed, channel.closedAt = block.timestamp
   ↓
7. TokenNetwork emits: ChannelClosed(channelId, bob, nonce, balanceHash)
   ↓
8. Challenge Period Starts (duration = settlementTimeout, e.g., 1 hour)

OPTIONAL: During Challenge Period
   ↓
9. Alice calls: tokenNetwork.updateNonClosingBalanceProof(channelId, bobBalanceProof, bobSignature)
   ↓
10. TokenNetwork validates: channel is Closed, alice is non-closer
    ↓
11. TokenNetwork validates: challenge period has not expired
    ↓
12. TokenNetwork verifies: bobBalanceProof signature using EIP-712
    ↓
13. TokenNetwork validates: bobBalanceProof.nonce > stored nonce (newer state)
    ↓
14. TokenNetwork updates: bob's nonce and transferredAmount with newer state
    ↓
15. TokenNetwork emits: NonClosingBalanceProofUpdated(channelId, alice, nonce, balanceHash)

After Challenge Period Expires
   ↓
16. Anyone calls: tokenNetwork.settleChannel(channelId)
    ↓
17. TokenNetwork validates: channel is Closed, challenge period expired
    ↓
18. TokenNetwork calculates final balances:
    - Alice receives: aliceDeposit - aliceTransferred + bobTransferred
    - Bob receives: bobDeposit - bobTransferred + aliceTransferred
    ↓
19. TokenNetwork transfers tokens using SafeERC20.safeTransfer to both participants
    ↓
20. TokenNetwork updates: channel.state = Settled
    ↓
21. TokenNetwork emits: ChannelSettled(channelId, aliceAmount, bobAmount)
```

**EIP-712 Signature Verification:**

[Source: Epic 8 Story 8.4 Balance Proof Verification]

EIP-712 provides structured data signing for off-chain balance proofs. Prevents signature replay across chains and contracts.

```solidity
// EIP-712 Domain Separator (set in constructor)
contract TokenNetwork is ReentrancyGuard, EIP712 {
    constructor(address _token) EIP712("TokenNetwork", "1") {
        token = _token;
    }
}

// Balance Proof Type Hash
bytes32 private constant BALANCE_PROOF_TYPEHASH = keccak256(
    "BalanceProof(bytes32 channelId,uint256 nonce,uint256 transferredAmount,uint256 lockedAmount,bytes32 locksRoot)"
);

// Signature Verification in closeChannel
function closeChannel(bytes32 channelId, BalanceProof memory balanceProof, bytes memory signature) external nonReentrant {
    // ... validation ...

    // Compute EIP-712 struct hash
    bytes32 structHash = keccak256(abi.encode(
        BALANCE_PROOF_TYPEHASH,
        balanceProof.channelId,
        balanceProof.nonce,
        balanceProof.transferredAmount,
        balanceProof.lockedAmount,
        balanceProof.locksRoot
    ));

    // Compute EIP-712 digest (includes domain separator)
    bytes32 digest = _hashTypedDataV4(structHash);

    // Recover signer from signature
    address recovered = ECDSA.recover(digest, signature);

    // Validate signer is non-closing participant
    if (recovered != nonClosingParticipant) revert InvalidSignature();

    // ... continue closure logic ...
}
```

**Why EIP-712?**

- **Domain Separation:** Signatures include chainId and contract address, prevent replay
- **Structured Data:** Human-readable signing in wallets (better UX than raw hashes)
- **Standard:** Widely adopted (MetaMask, Ledger, ethers.js support)
- **Security:** Prevents signature malleability attacks (via ECDSA library)

**Challenge Period Mechanism:**

[Source: Epic 8 Story 8.4 Security Considerations]

Challenge period protects non-closing participant from stale state submission.

**Challenge Period Properties:**

1. **Duration:** Set during channel opening (settlementTimeout, e.g., 1 hour for dev, 24 hours for production)
2. **Start:** When closeChannel is called (recorded in channel.closedAt)
3. **Challenge Window:** Non-closing participant can submit newer balance proof via updateNonClosingBalanceProof
4. **Nonce Validation:** Newer state must have nonce > stored nonce (monotonically increasing)
5. **Settlement:** Can only be called after challenge period expires (block.timestamp >= closedAt + settlementTimeout)

**Security Properties:**

- **Stale State Protection:** Monotonic nonces prevent replaying old balance proofs
- **No Griefing:** Anyone can call settleChannel after timeout (prevents closer from blocking settlement)
- **Dispute Resolution:** Non-closing participant has guaranteed window to challenge
- **Finality:** Once settled, channel state is Settled and cannot be re-opened

**Settlement Balance Calculation:**

[Source: Epic 8 Story 8.4 AC8]

Final balances calculated using cumulative deposits and transferred amounts:

```solidity
// Participant 1 final balance
uint256 participant1FinalBalance =
    participants[channelId][participant1].deposit           // Total deposited
    - participants[channelId][participant1].withdrawnAmount // Withdrawn during lifetime (Story 8.5)
    - participants[channelId][participant1].transferredAmount // Sent to participant2
    + participants[channelId][participant2].transferredAmount; // Received from participant2

// Participant 2 final balance
uint256 participant2FinalBalance =
    participants[channelId][participant2].deposit
    - participants[channelId][participant2].withdrawnAmount
    - participants[channelId][participant2].transferredAmount
    + participants[channelId][participant1].transferredAmount;
```

**Example:**

- Alice deposits 1000 USDC
- Bob deposits 1000 USDC
- Alice transfers 250 USDC to Bob (off-chain balance proof)
- Bob transfers 100 USDC to Alice (off-chain balance proof)
- Settlement:
  - Alice receives: 1000 - 250 + 100 = 850 USDC
  - Bob receives: 1000 - 100 + 250 = 1150 USDC

**Simplification for Story 8.4:**

Story 8.4 does NOT implement:

- **Cooperative Withdrawal:** withdrawnAmount always 0 (deferred to Story 8.5)
- **HTLCs (Hash Time-Locked Contracts):** lockedAmount and locksRoot ignored (deferred to Story 8.5+)
- **Penalty Mechanism:** No slashing for fraudulent closure (deferred to Story 8.5)

Story 8.4 focuses on basic closure with challenge period and settlement distribution.

### Data Models

**BalanceProof Struct:**

[Source: Epic 8 Story 8.4 Balance Proof Verification]

```solidity
// Off-chain state representation for channel closure
struct BalanceProof {
    bytes32 channelId;      // Channel identifier (must match on-chain channel)
    uint256 nonce;          // Monotonically increasing state counter (prevents replay)
    uint256 transferredAmount;  // Cumulative amount sent to counterparty
    uint256 lockedAmount;       // Amount in pending HTLCs (ignored in Story 8.4)
    bytes32 locksRoot;          // Merkle root of hash-locked transfers (ignored in Story 8.4)
}

// Story 8.4 scope: Only channelId, nonce, and transferredAmount are used
// lockedAmount and locksRoot are placeholders for future HTLC support (Story 8.5+)
```

**ParticipantState Struct (Modified from Story 8.3):**

[Source: Epic 8 Story 8.3 Channel State Structure, Story 8.4 modifications]

```solidity
// Per-participant state (per channelId + participant address)
struct ParticipantState {
    uint256 deposit;          // Total deposited by participant (Story 8.3)
    uint256 withdrawnAmount;  // Withdrawn during channel lifetime (Story 8.5, always 0 for 8.4)
    bool isCloser;            // True if this participant initiated channel closure (Story 8.4)
    uint256 nonce;            // Monotonically increasing state counter (Story 8.4)
    uint256 transferredAmount; // Cumulative amount sent to counterparty (Story 8.4)
}

// Story 8.4 changes:
// - Added: transferredAmount field (replaces balanceHash for simplicity)
// - Story 8.3 had: bytes32 balanceHash (deferred to Story 8.5 for HTLC support)
```

**Channel Struct (Unchanged from Story 8.3):**

[Source: Epic 8 Story 8.3 Channel State Structure]

```solidity
// Channel metadata (per channelId)
struct Channel {
    uint256 settlementTimeout;  // Challenge period duration in seconds (e.g., 3600 = 1 hour)
    ChannelState state;         // Current state: NonExistent | Opened | Closed | Settled
    uint256 closedAt;           // Block timestamp when channel closed (0 if not closed)
    address participant1;       // First participant (normalized: p1 < p2 lexicographically)
    address participant2;       // Second participant (normalized: p2 > p1 lexicographically)
}

// Story 8.4 uses closedAt to track challenge period start
```

**ChannelState Enum (Unchanged from Story 8.3):**

[Source: Epic 8 Story 8.3 AC6]

```solidity
// Channel lifecycle states
enum ChannelState {
    NonExistent,  // 0: Channel doesn't exist (default mapping value)
    Opened,       // 1: Channel active, deposits and off-chain payments allowed (Story 8.3)
    Closed,       // 2: Channel closed, challenge period active (Story 8.4)
    Settled       // 3: Channel settled, funds distributed (Story 8.4)
}

// Story 8.4 transitions: Opened → Closed → Settled
```

**Custom Errors (Story 8.4 Additions):**

[Source: Epic 8 Story 8.4, Story 8.3 custom errors pattern]

```solidity
// Story 8.3 errors (reused in 8.4)
error InvalidParticipant();
error InvalidChannelState();

// Story 8.4 new errors
error InvalidBalanceProof();        // Balance proof validation failed
error InvalidSignature();           // Signature recovery failed or wrong signer
error InvalidNonce();               // Nonce not greater than stored nonce
error CallerIsCloser();             // updateNonClosingBalanceProof called by closer
error ChallengePeriodExpired();     // Challenge period has ended
error SettlementTimeoutNotExpired(); // Settlement called too early
```

**Events (Story 8.4 Additions):**

[Source: Epic 8 Story 8.3 AC9 event pattern]

```solidity
// Story 8.3 events (existing)
event ChannelOpened(bytes32 indexed channelId, address indexed participant1, address indexed participant2, uint256 settlementTimeout);
event ChannelNewDeposit(bytes32 indexed channelId, address indexed participant, uint256 totalDeposit);

// Story 8.4 new events
event ChannelClosed(
    bytes32 indexed channelId,   // Channel ID (indexed)
    address indexed closingParticipant, // Participant who closed channel (indexed)
    uint256 nonce,                // Nonce of submitted balance proof
    bytes32 balanceHash           // Hash of balance proof data
);
// Emitted when: Channel closed with balance proof
// Purpose: Off-chain indexing of channel closure

event NonClosingBalanceProofUpdated(
    bytes32 indexed channelId,   // Channel ID (indexed)
    address indexed participant,  // Non-closing participant who challenged (indexed)
    uint256 nonce,                // Nonce of newer balance proof
    bytes32 balanceHash           // Hash of newer balance proof data
);
// Emitted when: Non-closing participant submits newer state during challenge
// Purpose: Track challenge submissions

event ChannelSettled(
    bytes32 indexed channelId,   // Channel ID (indexed)
    uint256 participant1Amount,   // Final amount transferred to participant1
    uint256 participant2Amount    // Final amount transferred to participant2
);
// Emitted when: Channel settled and funds distributed
// Purpose: Track settlement finality
```

### Project Structure Notes

**Files to Modify:**

[Source: Epic 8 Story 8.4 tasks, Story 8.3 project structure]

1. **Smart Contracts:**
   - Modify: `packages/contracts/src/TokenNetwork.sol` - Add closure and settlement logic (~300-400 new lines)
   - Changes: Add EIP712 inheritance, BalanceProof struct, closeChannel/updateNonClosingBalanceProof/settleChannel functions, signature verification logic
   - Modify ParticipantState struct: Replace `bytes32 balanceHash` with `uint256 transferredAmount`

2. **Test Contracts:**
   - Modify: `packages/contracts/test/TokenNetwork.t.sol` - Add closure and settlement tests (~400-500 new lines)
   - Add helper functions: createAndFundChannel, signBalanceProof
   - Add 10+ new test functions covering closure, challenge, settlement, error cases

3. **Documentation:**
   - Modify: `docs/guides/smart-contract-development.md` - Add Channel Closure and Settlement section (~100 lines)
   - Modify: `README.md` - Update Smart Contract Development section (~5 lines)

**No New Files to Create:**

Story 8.4 modifies existing TokenNetwork.sol and TokenNetwork.t.sol files, does not create new contracts.

**Project Structure After Story 8.4:**

```
packages/contracts/
├── src/
│   ├── TokenNetworkRegistry.sol  # Story 8.2 (unchanged)
│   └── TokenNetwork.sol           # MODIFIED: Add closure and settlement (Story 8.4)
├── test/
│   ├── TokenNetworkRegistry.t.sol # Story 8.2 (unchanged)
│   ├── TokenNetwork.t.sol         # MODIFIED: Add closure/settlement tests (Story 8.4)
│   └── mocks/
│       └── MockERC20.sol          # Story 8.3 (unchanged)
├── script/
│   └── Deploy.s.sol               # Story 8.2 (unchanged)
├── foundry.toml                   # Story 8.1 (unchanged)
├── .env                           # Story 8.1 (unchanged)
└── .env.example                   # Story 8.1 (unchanged)
```

### Technical Constraints

**OpenZeppelin EIP712 and ECDSA Requirements:**

[Source: Epic 8 Story 8.4 AC2, OpenZeppelin v5.x]

**Constraint:** All signature verification must use OpenZeppelin EIP712 and ECDSA libraries

**Rationale:**

- EIP-712 provides domain separation (prevents cross-chain/cross-contract replay)
- ECDSA handles signature malleability (returns address(0) for invalid signatures)
- Battle-tested in production (Uniswap, Aave use these libraries)

**Implementation:**

```solidity
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract TokenNetwork is ReentrancyGuard, EIP712 {
    constructor(address _token) EIP712("TokenNetwork", "1") {
        token = _token;
    }

    function closeChannel(...) external nonReentrant {
        // Compute EIP-712 digest
        bytes32 digest = _hashTypedDataV4(structHash);

        // Recover signer using ECDSA
        address recovered = ECDSA.recover(digest, signature);

        // Validate signer
        if (recovered != expectedSigner) revert InvalidSignature();
    }
}
```

**Challenge Period Minimum:**

[Source: Epic 8 Story 8.3 AC3, Story 8.4 challenge period]

**Constraint:** Settlement timeout must be >= 1 hour (3600 seconds)

**Rationale:**

- Gives non-closing participant time to detect stale state and challenge
- Production may use 24 hours, but 1 hour sufficient for dev/testing
- Prevents instant-close griefing attacks

**Implementation:**

```solidity
// Validated during channel opening (Story 8.3)
uint256 constant MIN_SETTLEMENT_TIMEOUT = 1 hours; // 3600 seconds

function openChannel(..., uint256 settlementTimeout) external {
    if (settlementTimeout < MIN_SETTLEMENT_TIMEOUT) revert InvalidSettlementTimeout();
    // ...
}

// Used during settlement (Story 8.4)
function settleChannel(bytes32 channelId) external {
    if (block.timestamp < channel.closedAt + channel.settlementTimeout) {
        revert SettlementTimeoutNotExpired();
    }
    // ...
}
```

**Balance Verification Pattern (From Story 8.3):**

[Source: Epic 8 Story 8.3 Security Requirements - Balance Verification]

**Constraint:** Settlement transfers must use SafeERC20.safeTransfer (not safeTransferFrom)

**Pattern:**

```solidity
// During settlement (Story 8.4)
if (participant1FinalBalance > 0) {
    IERC20(token).safeTransfer(channel.participant1, participant1FinalBalance);
}

// Use safeTransfer (contract owns tokens), not safeTransferFrom (caller owns tokens)
```

**Impact:** Ensures safe token transfers during settlement, handles non-standard ERC20 tokens

**Simplification: No HTLC Support in Story 8.4:**

[Source: Architecture simplification for MVP]

**Decision:** Story 8.4 ignores `lockedAmount` and `locksRoot` in BalanceProof

**Rationale:**

- HTLC support requires complex conditional transfer logic
- Story 8.4 focuses on basic closure with challenge period
- HTLC support deferred to Story 8.5+ security hardening

**Implementation:**

```solidity
// BalanceProof includes lockedAmount and locksRoot for future HTLC support
struct BalanceProof {
    bytes32 channelId;
    uint256 nonce;
    uint256 transferredAmount;
    uint256 lockedAmount;    // Ignored in Story 8.4 (always 0)
    bytes32 locksRoot;       // Ignored in Story 8.4 (always 0)
}

// Settlement calculation ignores locked amounts
uint256 finalBalance = deposit - withdrawnAmount - transferredAmount + counterpartyTransferred;
// lockedAmount not included in Story 8.4
```

**Impact:** Story 8.4 settlement works for simple balance transfers, HTLC conditional transfers deferred

### Testing Requirements

**Test Standards:**

[Source: test-strategy-and-standards.md, Epic 8 Story 8.4 AC10]

**Testing Strategy for Story 8.4:**

Story 8.4 testing focuses on verifying channel closure, challenge mechanism, settlement distribution, and signature verification.

**Foundry Unit Tests (Task 7):**

1. **testCloseChannel:**
   - Test: Happy path channel closure
   - Coverage: closeChannel function, EIP-712 signature verification, ChannelClosed event
   - Expected: Channel state updated to Closed, closer recorded, nonce updated

2. **testCloseChannelRevertsOnInvalidState:**
   - Test: State validation
   - Coverage: InvalidChannelState custom error
   - Expected: closeChannel on non-Opened channel reverts

3. **testCloseChannelRevertsOnInvalidSignature:**
   - Test: Signature verification
   - Coverage: InvalidSignature custom error, ECDSA.recover
   - Expected: closeChannel with invalid signature reverts

4. **testCloseChannelRevertsOnStaleNonce:**
   - Test: Nonce validation
   - Coverage: InvalidNonce custom error, stale state protection
   - Expected: closeChannel with nonce <= stored nonce reverts

5. **testUpdateNonClosingBalanceProof:**
   - Test: Happy path challenge
   - Coverage: updateNonClosingBalanceProof function, nonce validation
   - Expected: Non-closer's balance proof updated with newer state

6. **testUpdateNonClosingBalanceProofRevertsOnExpiredChallenge:**
   - Test: Challenge period validation
   - Coverage: ChallengePeriodExpired custom error
   - Expected: Challenge after timeout reverts

7. **testUpdateNonClosingBalanceProofRevertsOnNonMonotonicNonce:**
   - Test: Nonce monotonicity
   - Coverage: InvalidNonce custom error
   - Expected: Challenge with non-increasing nonce reverts

8. **testSettleChannel:**
   - Test: Happy path settlement
   - Coverage: settleChannel function, balance calculation, SafeERC20 transfers
   - Expected: Final balances calculated and distributed correctly

9. **testSettleChannelWithChallenge:**
   - Test: Settlement after challenge
   - Coverage: Challenge mechanism integration with settlement
   - Expected: Settlement uses challenged (newer) state for balance calculation

10. **testSettleChannelRevertsBeforeTimeout:**
    - Test: Timeout validation
    - Coverage: SettlementTimeoutNotExpired custom error
    - Expected: Settlement before challenge period reverts

11. **testSettleChannelRevertsOnWrongState:**
    - Test: State validation
    - Coverage: InvalidChannelState custom error
    - Expected: Settlement on non-Closed channel reverts

12. **testBilateralTransfers:**
    - Test: Both participants transfer
    - Coverage: Balance calculation with bilateral transfers
    - Expected: Final balances account for both directions of transfer

**Test Helper Functions:**

1. **createAndFundChannel:**
   - Purpose: Reduce test boilerplate
   - Implementation: Opens channel and deposits for both participants
   - Returns: channelId

2. **signBalanceProof:**
   - Purpose: Generate EIP-712 signatures for tests
   - Implementation: Uses Foundry vm.sign with private keys
   - Returns: signature bytes

**Test Coverage Goals:**

[Source: test-strategy-and-standards.md]

- **TokenNetwork.sol:** >90% line coverage (critical contract)
- **All public functions:** 100% coverage (closeChannel, updateNonClosingBalanceProof, settleChannel)
- **All error paths:** 100% coverage (custom errors triggered in tests)
- **All events:** 100% coverage (ChannelClosed, NonClosingBalanceProofUpdated, ChannelSettled emitted and validated)

**Integration Tests:**

Story 8.4 does not require integration tests beyond unit tests. On-chain deployment verification can use Foundry cast CLI (similar to Story 8.3 Task 5).

**No E2E Tests Required:** Story 8.4 is smart contract development with no user-facing workflows

**Manual Testing:**

1. **Foundry Compilation:**
   - Run `forge build` (verify contracts compile without errors)

2. **Foundry Test Execution:**
   - Run `forge test` (verify all tests pass)
   - Run `forge coverage` (verify >90% coverage)

**Acceptance Criteria Validation:**

| AC   | Validation Method                                                     |
| ---- | --------------------------------------------------------------------- |
| AC1  | Unit test: testCloseChannel                                           |
| AC2  | Unit test: testCloseChannelRevertsOnInvalidSignature                  |
| AC3  | Unit test: testCloseChannel (verify closer recorded)                  |
| AC4  | Unit test: testCloseChannel (verify challenge period starts)          |
| AC5  | Unit test: testUpdateNonClosingBalanceProof                           |
| AC6  | Unit test: testUpdateNonClosingBalanceProofRevertsOnNonMonotonicNonce |
| AC7  | Unit test: testSettleChannel                                          |
| AC8  | Unit test: testSettleChannel, testBilateralTransfers                  |
| AC9  | Unit test: testSettleChannel (SafeERC20 usage)                        |
| AC10 | Foundry: forge test (12+ tests passing)                               |

### Coding Standards

**Core Standards:**

[Source: coding-standards.md]

**Solidity Coding Standards (Epic 8):**

- **Solidity Version:** 0.8.20 (specified in foundry.toml, pragma in all .sol files)
- **File Naming:** PascalCase for contracts: `TokenNetwork.sol`
- **Contract Naming:** Match filename: `contract TokenNetwork {}`
- **Function Naming:** camelCase: `closeChannel()`, `settleChannel()`, `updateNonClosingBalanceProof()`
- **State Variables:** camelCase for public: `channelCounter`, `token`
- **Mappings:** Descriptive names: `channels`, `participants`
- **Constants:** UPPER_SNAKE_CASE: `bytes32 private constant BALANCE_PROOF_TYPEHASH = ...`
- **Events:** PascalCase: `event ChannelClosed(...);`
- **Errors:** PascalCase: `error InvalidSignature();`
- **Visibility:** Explicit visibility for all functions: `external`, `public`, `internal`, `private`

**NatSpec Documentation Standards:**

[Source: Story 8.3 coding standards, Foundry best practices]

- **Function-level NatSpec:**

  ```solidity
  /// @notice Close a payment channel with a balance proof from the counterparty
  /// @param channelId The unique identifier for the channel
  /// @param balanceProof The off-chain balance proof signed by the non-closing participant
  /// @param signature The EIP-712 signature of the balance proof
  /// @dev Validates signature using EIP-712, records closer, starts challenge period
  function closeChannel(bytes32 channelId, BalanceProof memory balanceProof, bytes memory signature)
      external
      nonReentrant
  { ... }
  ```

- **Struct NatSpec:**

  ```solidity
  /// @notice Off-chain state representation for channel closure
  struct BalanceProof {
      bytes32 channelId;      /// Channel identifier
      uint256 nonce;          /// Monotonically increasing state counter
      uint256 transferredAmount;  /// Cumulative amount sent to counterparty
      uint256 lockedAmount;       /// Amount in pending HTLCs (unused in Story 8.4)
      bytes32 locksRoot;          /// Merkle root of hash-locked transfers (unused in Story 8.4)
  }
  ```

- **Event NatSpec:**

  ```solidity
  /// @notice Emitted when a channel is closed
  /// @param channelId The unique channel identifier
  /// @param closingParticipant The participant who initiated closure
  /// @param nonce The nonce of the submitted balance proof
  /// @param balanceHash The hash of the balance proof data
  event ChannelClosed(
      bytes32 indexed channelId,
      address indexed closingParticipant,
      uint256 nonce,
      bytes32 balanceHash
  );
  ```

- **Error NatSpec:**

  ```solidity
  /// @notice Thrown when balance proof signature verification fails
  error InvalidSignature();
  ```

**Foundry Test Naming:**

[Source: Story 8.3 Foundry test pattern]

- **Test Files:** `TokenNetwork.t.sol` - Foundry convention
- **Test Contract:** `contract TokenNetworkTest is Test {}`
- **Test Functions:** `function test<Functionality>() public {}`
- **Example:** `function testCloseChannel() public {}`
- **Revert Tests:** `function test<Functionality>RevertsOn<Condition>() public {}`
- **Example:** `function testCloseChannelRevertsOnInvalidSignature() public {}`

**Import Organization:**

[Source: Solidity style guide]

1. External dependencies (OpenZeppelin) first
2. Internal dependencies (project contracts) second
3. Alphabetical order within each group

```solidity
// External
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// Internal
// (none for TokenNetwork)
```

**Code Layout:**

[Source: Solidity style guide]

1. SPDX license identifier
2. Pragma statement
3. Imports
4. Errors
5. Events
6. Structs
7. State variables
8. Constructor
9. External functions
10. Public functions
11. Internal functions
12. Private functions

### Integration Points

**Current Integration (Story 8.4):**

- **Story 8.1 (Foundry Environment):** TokenNetwork uses Foundry project structure, Solidity 0.8.20, OpenZeppelin v5.5.0 (EIP712, ECDSA for Story 8.4)
- **Story 8.2 (TokenNetworkRegistry):** TokenNetworkRegistry.createTokenNetwork() deploys TokenNetwork
- **Story 8.3 (Channel Opening and Deposits):** TokenNetwork channel opening and deposits provide foundation for closure
- **Epic 7 Story 7.1 (Anvil Docker Service):** TokenNetwork deploys to local Anvil at http://localhost:8545
- **Monorepo Structure:** TokenNetwork in `packages/contracts/` follows monorepo pattern

**Future Integration (Epic 8 Stories 8.5-8.10):**

Story 8.4 integration points for future stories:

- **Epic 8.5 (Security Hardening):** TokenNetwork adds cooperative settlement, withdrawal, pausable, channel expiry
- **Epic 8.6 (Testing & Audit):** TokenNetwork included in security audit scope, fuzz tests added for closure mechanism
- **Epic 8.7 (TypeScript SDK):** SDK uses TokenNetwork to close channels, challenge states, settle on-chain
- **Epic 8.8 (Settlement Engine):** Settlement executor calls TokenNetwork.settleChannel() after ILP settlement threshold reached
- **Epic 8.9 (Channel Lifecycle):** Channel manager monitors TokenNetwork events, manages closure and settlement automatically
- **Epic 8.10 (Dashboard):** Dashboard queries TokenNetwork state, displays closed channels, challenge period countdowns

**API for Future Stories:**

```solidity
// Epic 8.7 SDK usage
const tokenNetworkAddress = await registry.getTokenNetwork(usdcAddress);
const tokenNetwork = new ethers.Contract(tokenNetworkAddress, TokenNetworkABI, signer);

// Close channel (unilateral)
const balanceProof = {
    channelId: channelId,
    nonce: 1,
    transferredAmount: 250,
    lockedAmount: 0,
    locksRoot: ethers.constants.HashZero
};
const signature = await counterparty.signTypedData(domain, types, balanceProof);
await tokenNetwork.closeChannel(channelId, balanceProof, signature);

// Challenge closure (non-closer submits newer state)
const newerBalanceProof = { ...balanceProof, nonce: 2, transferredAmount: 500 };
const newerSignature = await closer.signTypedData(domain, types, newerBalanceProof);
await tokenNetwork.updateNonClosingBalanceProof(channelId, newerBalanceProof, newerSignature);

// Settle channel (after challenge period)
await ethers.provider.send("evm_increaseTime", [settlementTimeout]);
await tokenNetwork.settleChannel(channelId);

// Query channel state
const channel = await tokenNetwork.channels(channelId);
console.log("State:", channel.state); // 3 = Settled
```

### Risks and Mitigations

**Risk 1: EIP-712 Signature Malleability**

- **Risk:** Malicious participant could manipulate signature (v, r, s) to create alternative valid signatures
- **Probability:** Low (OpenZeppelin ECDSA library handles malleability)
- **Mitigation:** Use OpenZeppelin ECDSA.recover() which validates v parameter and prevents malleability
- **Mitigation:** Validate recovered address is not address(0) (ECDSA.recover returns 0 for invalid signatures)
- **Impact:** Low. OpenZeppelin ECDSA library is battle-tested and prevents malleability attacks.

**Risk 2: Challenge Period Too Short**

- **Risk:** 1 hour minimum timeout may be insufficient for non-closer to detect stale state and challenge
- **Probability:** Medium (1 hour suitable for dev/testing, production may need 24 hours)
- **Mitigation:** Use configurable minimum via MIN_SETTLEMENT_TIMEOUT constant
- **Mitigation:** Production deployment increases timeout to 24 hours or more
- **Impact:** Medium. Short challenge period could allow stale state finalization if counterparty offline.

**Risk 3: Signature Replay Across Chains/Contracts**

- **Risk:** Balance proof signature valid on one chain could be replayed on another chain or contract
- **Probability:** Low (EIP-712 domain separator includes chainId and verifyingContract)
- **Mitigation:** Inherit OpenZeppelin EIP712 with domain separator: `EIP712("TokenNetwork", "1")`
- **Mitigation:** Domain separator includes chainId (prevents cross-chain replay) and contract address (prevents cross-contract replay)
- **Impact:** Low. EIP-712 domain separation is standard practice and prevents replay attacks.

**Risk 4: Settlement Race Condition**

- **Risk:** Multiple parties could call settleChannel simultaneously after challenge period expires
- **Probability:** Low (Solidity execution is sequential per block)
- **Mitigation:** Check channel.state == Closed before settlement, update to Settled atomically
- **Mitigation:** ReentrancyGuard prevents reentrancy during settlement
- **Impact:** Negligible. First transaction updates state to Settled, subsequent transactions revert.

**Risk 5: Balance Calculation Overflow**

- **Risk:** Calculation of final balances could overflow uint256
- **Probability:** Very Low (Solidity 0.8.x has built-in overflow checks)
- **Mitigation:** Solidity 0.8.20 reverts on overflow/underflow automatically
- **Mitigation:** Validate transferred amounts during closure (must be <= deposit)
- **Impact:** Negligible. Built-in overflow protection prevents arithmetic errors.

**Risk 6: Gas Griefing via Large Balance Proofs**

- **Risk:** Attacker could submit balance proof with very large lockedAmount/locksRoot requiring expensive verification
- **Probability:** Low (Story 8.4 ignores lockedAmount and locksRoot)
- **Mitigation:** Story 8.4 does not validate HTLC data, treats as zero
- **Mitigation:** Story 8.5+ security hardening may add HTLC validation with gas limits
- **Impact:** Low for Story 8.4. HTLC gas costs deferred to Story 8.5+.

### Out of Scope for Story 8.4

**Explicitly NOT included in this story:**

1. **Cooperative Settlement:** Story 8.5 adds cooperativeSettle() function bypassing challenge period with both signatures
2. **Cooperative Withdrawal:** Story 8.5 adds withdraw() function for removing funds while channel is open
3. **HTLC Support:** Story 8.4 ignores lockedAmount and locksRoot, HTLC logic deferred to Story 8.5+
4. **Penalty Mechanism:** Story 8.5 may add slashing for fraudulent closure (deposit penalty)
5. **Channel Expiry:** Story 8.5 adds force-close after max channel lifetime (e.g., 1 year)
6. **Gas Optimization Analysis:** Story 8.6 benchmarks and optimizes gas costs for closure/settlement
7. **Comprehensive Test Suite:** Story 8.4 includes basic unit tests, Story 8.6 expands to >95% coverage with fuzz/invariant tests
8. **Security Audit:** Story 8.6 professional security audit
9. **TypeScript SDK Integration:** Story 8.7 implements SDK using TokenNetwork closure functions
10. **Settlement Engine Integration:** Story 8.8 integrates payment channels with TigerBeetle

### Technical Debt and Future Work

**Technical Debt Incurred:**

1. **Simplified Balance Proof Storage:**
   - **Debt:** Store transferredAmount directly in ParticipantState instead of balanceHash
   - **Future Work:** Story 8.5+ may revert to balanceHash pattern for HTLC support
   - **Impact:** Low. Current implementation works for simple transfers, HTLC requires balanceHash.

2. **No HTLC Support:**
   - **Debt:** Story 8.4 ignores lockedAmount and locksRoot in BalanceProof
   - **Future Work:** Story 8.5+ implements HTLC conditional transfer validation
   - **Impact:** Medium. Channels support simple transfers only, no conditional payments yet.

3. **No Cooperative Settlement:**
   - **Debt:** Story 8.4 only supports unilateral closure with challenge period
   - **Future Work:** Story 8.5 adds cooperativeSettle() function with both signatures (no challenge period)
   - **Impact:** Low. Unilateral closure works but requires waiting for challenge period. Cooperative settlement is UX improvement.

4. **No Penalty for Fraudulent Closure:**
   - **Debt:** Participant can submit stale state without penalty
   - **Future Work:** Story 8.5 may add slashing mechanism (deposit penalty for fraudulent closure)
   - **Impact:** Low. Challenge mechanism prevents stale state finalization, but no incentive against attempting fraud.

5. **No Withdrawal Function:**
   - **Debt:** withdrawnAmount field in ParticipantState is unused (always 0)
   - **Future Work:** Story 8.5 adds withdraw() function for removing funds while channel is open
   - **Impact:** Low. Participants can close and settle to retrieve funds, withdrawal is convenience feature.

**Architecture Debt:**

None. TokenNetwork follows Raiden Network proven pattern without architectural compromises. Channel closure and settlement logic is production-ready for basic transfers.

### Success Criteria

**Story 8.4 is successful when:**

1. ✅ `closeChannel()` function implemented with EIP-712 signature verification
2. ✅ Close function validates balance proof signature and records closing participant
3. ✅ Challenge period starts on channel close (channel.closedAt = block.timestamp)
4. ✅ `updateNonClosingBalanceProof()` allows counterparty to submit newer state
5. ✅ Newer state validated by comparing nonces (must be strictly greater)
6. ✅ `settleChannel()` function distributes final balances after challenge period
7. ✅ Settlement calculates final balances: deposit - transferred + received
8. ✅ Settlement transfers tokens using SafeERC20.safeTransfer
9. ✅ Foundry unit tests pass (12+ tests, >90% coverage)
10. ✅ All events emitted for state transitions

**Quality Metrics:**

- Compilation: forge build succeeds with 0 errors
- Tests: forge test passes 12/12 tests (100%)
- Coverage: >90% for TokenNetwork.sol (including closure logic)
- Gas efficiency: closeChannel <120k gas, settleChannel <100k gas (measured in Story 8.6)

**Epic 8 Completion Criteria Contribution:**

- ✅ Foundry development environment initialized (Story 8.1 deliverable)
- ✅ TokenNetworkRegistry factory contract implemented (Story 8.2 deliverable)
- ✅ TokenNetwork core contract implemented (Story 8.3 deliverable)
- ✅ Channel closure and settlement logic (Story 8.4 deliverable)
- ⏳ Smart contracts pass comprehensive test suite >95% coverage (Story 8.6)
- ⏳ Professional security audit completed (Story 8.6)
- ⏳ Payment channel SDK functional (Story 8.7)
- ⏳ Settlement executor integrated (Story 8.8)
- ⏳ Channel lifecycle manager implemented (Story 8.9)
- ⏳ Dashboard displays payment channels (Story 8.10)

## QA Results

### Review Date: 2026-01-09

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**EXCELLENT** - Story 8.4 delivers production-ready channel closure and settlement implementation with comprehensive EIP-712 signature verification, robust challenge period mechanism, and accurate balance distribution. The implementation adds 233 lines of high-quality Solidity code to TokenNetwork.sol and 12 comprehensive test functions covering all acceptance criteria.

**Key Strengths:**

- Complete implementation of all 10 acceptance criteria
- 27 passing tests (15 from Story 8.3 + 12 new for Story 8.4) with 100% success rate
- EIP-712 signature verification correctly implemented using OpenZeppelin libraries
- Challenge period mechanism provides security against stale state submission
- Monotonic nonce validation prevents replay attacks
- SafeERC20 used for all token transfers during settlement
- Comprehensive test coverage including edge cases and error scenarios
- Clean separation of concerns: closeChannel, updateNonClosingBalanceProof, settleChannel

**Architecture Compliance:**

- Follows Raiden Network proven patterns for channel closure
- Correctly implements EIP-712 typed structured data signing
- Proper use of OpenZeppelin EIP712 and ECDSA libraries
- ReentrancyGuard applied to all external functions
- Custom errors for gas optimization

### Refactoring Performed

No refactoring required. The implementation is clean, follows established patterns from Story 8.3, and requires no modifications.

### Compliance Check

- **Coding Standards:** ⚠️ **CONCERNS** - Solidity version mismatch
  - Story 8.4 specification requires Solidity 0.8.20
  - Implementation uses Solidity 0.8.24 (pragma and foundry.toml)
  - This appears to be an intentional upgrade from Story 8.3 QA review (which also passed with 0.8.24)
  - OpenZeppelin v5.5.0 is compatible with 0.8.24
  - **Recommendation:** Update Story 8.4 Dev Notes to document Solidity 0.8.24 as the project standard, or revert to 0.8.20 if strict version requirement is critical
  - **Impact:** Low - Both versions work correctly, but story documentation should match implementation

- **Project Structure:** ✓ **PASS**
  - Files modified as specified (TokenNetwork.sol, TokenNetwork.t.sol, smart-contract-development.md)
  - No unnecessary files created
  - Proper test organization with helper functions

- **Testing Strategy:** ✓ **PASS**
  - 12 new comprehensive tests for Story 8.4 functionality
  - All closure, challenge, and settlement scenarios covered
  - Error cases validated with vm.expectRevert
  - Gas usage measured: closeChannel 117k-133k gas, settleChannel 56k-73k gas, updateNonClosingBalanceProof 78k-94k gas
  - All tests passing (27/27)

- **All ACs Met:** ✓ **PASS**
  - AC1-10 fully implemented and validated by tests

### Improvements Checklist

All improvements already completed by dev team:

- [x] closeChannel() function with EIP-712 signature verification (TokenNetwork.sol:223-290)
- [x] updateNonClosingBalanceProof() for challenge mechanism (TokenNetwork.sol:292-359)
- [x] settleChannel() with balance distribution (TokenNetwork.sol:361-405)
- [x] EIP-712 domain separator and type hash (TokenNetwork.sol:26-28, constructor)
- [x] Comprehensive test coverage (TokenNetwork.t.sol: testCloseChannel, testUpdateNonClosingBalanceProof, testSettleChannel, etc.)
- [x] Error handling with custom errors (InvalidBalanceProof, InvalidSignature, InvalidNonce, etc.)
- [x] Event emission for all state transitions (ChannelClosed, NonClosingBalanceProofUpdated, ChannelSettled)
- [x] Documentation updated (smart-contract-development.md with channel closure examples)
- [ ] **DOCUMENTATION:** Update Story 8.4 Dev Notes to clarify Solidity 0.8.24 is the project standard (minor documentation inconsistency)

### Security Review

**PASS** - Comprehensive security analysis reveals no vulnerabilities:

1. **EIP-712 Signature Verification:** ✓ SECURE
   - Correct implementation using OpenZeppelin EIP712 and ECDSA
   - Domain separator includes chainId and contract address (prevents replay)
   - ECDSA.recover handles signature malleability
   - Proper validation: recovered address must match expected signer

2. **Challenge Period Mechanism:** ✓ SECURE
   - Monotonic nonce validation prevents stale state replay (nonce > storedNonce)
   - Challenge period timeout enforced (block.timestamp checks)
   - Non-closing participant can submit newer state during challenge window
   - Settlement blocked until challenge period expires

3. **Access Control:** ✓ SECURE
   - closeChannel: caller must be participant
   - updateNonClosingBalanceProof: caller must be non-closer, validated correctly
   - settleChannel: open to anyone (prevents griefing, correct design)

4. **Reentrancy Protection:** ✓ SECURE
   - ReentrancyGuard applied to closeChannel, updateNonClosingBalanceProof, settleChannel
   - State updates before external calls (checks-effects-interactions)

5. **Balance Calculation:** ✓ SECURE
   - Correct formula: deposit - withdrawn - transferred + received
   - Solidity 0.8.24 built-in overflow protection
   - SafeERC20.safeTransfer used for token distribution

6. **State Machine Security:** ✓ SECURE
   - Channel state validation enforced
   - Closed → Settled transition prevents double settlement
   - No way to reopen settled channels

**No security vulnerabilities identified.**

### Performance Considerations

**PASS** - Gas usage is reasonable and within expected ranges:

- **closeChannel:** 117k-133k gas (avg: 132k) - ✓ Under 150k target
- **settleChannel:** 56k-73k gas (avg: 73k) - ✓ Under 100k target
- **updateNonClosingBalanceProof:** 78k-94k gas (avg: 94k) - ✓ Reasonable for challenge mechanism

Gas optimization achieved through:

- Custom errors instead of require strings (~50 gas savings per error)
- Immutable token address (2100 gas savings per read)
- Efficient struct packing
- OpenZeppelin libraries are gas-optimized

**Performance is production-ready. Story 8.6 gas benchmarking may find additional micro-optimizations but current implementation is excellent.**

### Files Modified During Review

No files modified during QA review. Implementation is already production-ready.

### Gate Status

**Gate: PASS** → docs/qa/gates/8.4-smart-contract-development-channel-closure.yml

**Risk profile:** LOW - Implementation follows proven Raiden Network patterns with comprehensive test coverage

**NFR assessment:** All NFRs PASS (security, performance, reliability, maintainability)

### Test Coverage Analysis

**27 tests passing (100% success rate):**

- Story 8.3 baseline: 15 tests (channel opening and deposits)
- Story 8.4 additions: 12 tests (closure, challenge, settlement)

**Story 8.4 Test Functions:**

1. testCloseChannel - Happy path closure ✓
2. testCloseChannelRevertsOnInvalidState - State validation ✓
3. testCloseChannelRevertsOnInvalidSignature - Signature verification ✓
4. testCloseChannelRevertsOnStaleNonce - Nonce validation ✓
5. testUpdateNonClosingBalanceProof - Happy path challenge ✓
6. testUpdateNonClosingBalanceProofRevertsOnExpiredChallenge - Timeout validation ✓
7. testUpdateNonClosingBalanceProofRevertsOnNonMonotonicNonce - Nonce monotonicity ✓
8. testSettleChannel - Happy path settlement ✓
9. testSettleChannelWithChallenge - Settlement after challenge ✓
10. testSettleChannelRevertsBeforeTimeout - Timeout enforcement ✓
11. testSettleChannelRevertsOnWrongState - State validation ✓
12. testBilateralTransfers - Bilateral transfer logic ✓

**Coverage Assessment:**

- All 10 acceptance criteria have corresponding tests
- All error paths validated with vm.expectRevert
- All events validated with vm.expectEmit
- Edge cases covered: expired challenges, stale nonces, wrong states, bilateral transfers

**Estimated Coverage:** >95% line coverage for TokenNetwork.sol (Story 8.3 had 100%, Story 8.4 adds similar comprehensive coverage)

### Acceptance Criteria Validation

| AC  | Description                         | Implementation           | Test Coverage                                              | Status |
| --- | ----------------------------------- | ------------------------ | ---------------------------------------------------------- | ------ |
| 1   | closeChannel() function             | TokenNetwork.sol:223-290 | testCloseChannel                                           | ✓ PASS |
| 2   | EIP-712 signature validation        | TokenNetwork.sol:248-266 | testCloseChannelRevertsOnInvalidSignature                  | ✓ PASS |
| 3   | Record closer and balance proof     | TokenNetwork.sol:273-277 | testCloseChannel                                           | ✓ PASS |
| 4   | Challenge period starts             | TokenNetwork.sol:285-286 | testCloseChannel                                           | ✓ PASS |
| 5   | updateNonClosingBalanceProof()      | TokenNetwork.sol:292-359 | testUpdateNonClosingBalanceProof                           | ✓ PASS |
| 6   | Nonce validation (strictly greater) | TokenNetwork.sol:345-346 | testUpdateNonClosingBalanceProofRevertsOnNonMonotonicNonce | ✓ PASS |
| 7   | settleChannel() function            | TokenNetwork.sol:361-405 | testSettleChannel                                          | ✓ PASS |
| 8   | Balance calculation formula         | TokenNetwork.sol:374-389 | testSettleChannel, testBilateralTransfers                  | ✓ PASS |
| 9   | SafeERC20 token transfers           | TokenNetwork.sol:395-401 | testSettleChannel                                          | ✓ PASS |
| 10  | Unit tests verify all scenarios     | TokenNetwork.t.sol       | 27 passing tests                                           | ✓ PASS |

**All 10 acceptance criteria fully met and validated.**

### Recommended Status

**✓ Ready for Done**

Story 8.4 implementation is production-ready with one minor documentation inconsistency:

**Optional Follow-up (Non-blocking):**

- Update Story 8.4 Dev Notes section to document Solidity 0.8.24 as the project standard (currently specifies 0.8.20 but implementation uses 0.8.24 consistently with Story 8.3)
- This is a documentation-only issue, not a code issue
- Implementation works correctly with 0.8.24

**Quality Summary:**

- ✅ All acceptance criteria met
- ✅ Comprehensive test coverage (27/27 passing)
- ✅ Zero security vulnerabilities
- ✅ Gas-optimized implementation
- ✅ Production-ready code quality
- ⚠️ Minor documentation inconsistency (non-blocking)

**Story owner may mark as Done immediately or update documentation first (owner's choice).**

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Author                        |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
| 2026-01-09 | 1.0     | Initial story creation with comprehensive technical details from Epic 8 Story 8.4 requirements, architecture docs (tech-stack.md, coding-standards.md, source-tree.md), Story 8.3 completion insights (channel opening and deposits, OpenZeppelin v5.x patterns, Foundry test patterns), and Raiden Network channel closure architecture. Story implements channel closure with EIP-712 signature verification, challenge period mechanism, and settlement distribution. Story completes core payment channel lifecycle (opening, deposits, closure, settlement). | Claude (Story Creation Agent) |

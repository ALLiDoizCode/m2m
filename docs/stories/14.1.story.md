<!-- Powered by BMAD™ Core -->

# Story 14.1: Explorer Event Store (libSQL)

## Status

Done

## Story

**As a** connector operator,
**I want** all telemetry events persisted to a local database,
**So that** I can browse historical events in the Explorer UI and analyze connector activity over time.

## Acceptance Criteria

1. EventStore class wraps libSQL with telemetry schema
2. TelemetryEmitter writes to EventStore (in addition to WebSocket)
3. Events stored with all indexed fields extracted
4. Configurable retention policy (max age, max count)
5. Query API for filtered event retrieval with pagination
6. Unit tests cover all CRUD operations

## Tasks / Subtasks

- [x] Task 1: Create EventStore Class with libSQL Schema (AC: 1, 3)
  - [x] Create file: `packages/connector/src/explorer/event-store.ts`
  - [x] Define `EventStoreConfig` interface:
    ```typescript
    interface EventStoreConfig {
      path: string; // Database path (e.g., './data/explorer.db' or ':memory:')
      maxEventCount?: number; // Max events to retain (default: 1000000)
      maxAgeMs?: number; // Max event age in milliseconds (default: 7 days)
    }
    ```
  - [x] Implement EventStore class constructor:
    - Accept config and logger
    - Store config with defaults applied
  - [x] Implement `initialize()` method:
    - Create libSQL client using `@libsql/client`
    - Create events table with schema from PRD:
      ```sql
      CREATE TABLE IF NOT EXISTS events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        event_type TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        node_id TEXT NOT NULL,
        direction TEXT,
        peer_id TEXT,
        packet_id TEXT,
        amount TEXT,
        destination TEXT,
        payload TEXT NOT NULL
      );
      CREATE INDEX IF NOT EXISTS idx_events_type ON events(event_type);
      CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp DESC);
      CREATE INDEX IF NOT EXISTS idx_events_packet ON events(packet_id);
      CREATE INDEX IF NOT EXISTS idx_events_peer ON events(peer_id);
      ```
  - [x] [Source: docs/prd/epic-14-packet-event-explorer-ui.md lines 54-72]

- [x] Task 2: Implement Event Storage Method (AC: 1, 2, 3)
  - [x] Implement `storeEvent(event: TelemetryEvent): Promise<number>`:
    - Extract indexed fields from event based on event type
    - Map event.type to event_type column
    - Normalize timestamp using `normalizeTimestamp()` helper (see below)
    - Extract nodeId from event (all TelemetryEvent types have nodeId)
    - Extract direction from event if present (e.g., 'sent' | 'received' | 'internal')
    - Extract peerId from event if present
    - Extract packetId from event if present (channelId for channel events)
    - Extract amount from event if present (bigint as string)
    - Extract destination from event if present (ILP address or XRP destination)
    - Store full event JSON in payload column
    - Return inserted row ID
  - [x] Create helper function `normalizeTimestamp(event: TelemetryEvent): number`:
    ```typescript
    /**
     * Normalize timestamp to Unix milliseconds.
     * TelemetryEvent types use two formats:
     * - ISO 8601 string (e.g., '2026-01-24T12:00:00.000Z')
     * - Unix milliseconds number (e.g., 1737720000000)
     */
    function normalizeTimestamp(event: TelemetryEvent): number {
      const ts = (event as { timestamp: string | number }).timestamp;
      if (typeof ts === 'number') {
        return ts; // Already Unix ms
      }
      return new Date(ts).getTime(); // ISO 8601 → Unix ms
    }
    ```
  - [x] Create helper function `extractIndexedFields(event: TelemetryEvent): ExtractedFields`:
    ```typescript
    interface ExtractedFields {
      event_type: string;
      timestamp: number;
      node_id: string;
      direction: string | null;
      peer_id: string | null;
      packet_id: string | null;
      amount: string | null;
      destination: string | null;
    }
    ```
  - [x] Implement field extraction with switch on event.type (see Dev Notes → Field Extraction Mapping)
  - [x] [Source: packages/shared/src/types/telemetry.ts - TelemetryEvent union type]

- [x] Task 3: Implement Batch Storage Method (AC: 2)
  - [x] Implement `storeEvents(events: TelemetryEvent[]): Promise<void>`:
    - Use libSQL batch() for atomic transaction
    - Extract fields for each event
    - Insert all events atomically
    - Log batch size for debugging
  - [x] [Source: packages/connector/src/agent/event-database.ts lines 205-243 - batch pattern]

- [x] Task 4: Implement Query API with Filtering and Pagination (AC: 5)
  - [x] Define `EventQueryFilter` interface:
    ```typescript
    interface EventQueryFilter {
      eventTypes?: string[]; // Filter by event type(s)
      since?: number; // Unix timestamp (ms) lower bound
      until?: number; // Unix timestamp (ms) upper bound
      peerId?: string; // Filter by peer ID
      packetId?: string; // Filter by packet ID
      direction?: 'sent' | 'received' | 'internal'; // Filter by direction
      limit?: number; // Results per page (default: 50)
      offset?: number; // Pagination offset (default: 0)
    }
    ```
  - [x] Define `StoredEvent` interface:
    ```typescript
    interface StoredEvent {
      id: number;
      event_type: string;
      timestamp: number;
      node_id: string;
      direction: string | null;
      peer_id: string | null;
      packet_id: string | null;
      amount: string | null;
      destination: string | null;
      payload: TelemetryEvent; // Parsed JSON
    }
    ```
  - [x] Implement `queryEvents(filter: EventQueryFilter): Promise<StoredEvent[]>`:
    - Build WHERE clause dynamically based on filter
    - Apply pagination with LIMIT and OFFSET
    - Order by timestamp DESC (newest first)
    - Parse payload JSON back to TelemetryEvent
    - Return array of StoredEvent
  - [x] Implement `countEvents(filter: EventQueryFilter): Promise<number>`:
    - Same filter logic but returns COUNT(\*)
    - Used for pagination UI
  - [x] [Source: packages/connector/src/agent/event-database.ts lines 255-333 - query pattern]

- [x] Task 5: Implement Retention Policy Enforcement (AC: 4)
  - [x] Implement `pruneByAge(): Promise<number>`:
    - Delete events older than `config.maxAgeMs`
    - Use current timestamp - maxAgeMs as cutoff
    - Return count of deleted events
    - Log pruned count
  - [x] Implement `pruneByCount(): Promise<number>`:
    - Delete oldest events exceeding `config.maxEventCount`
    - Keep newest events up to limit
    - Return count of deleted events
    - Log pruned count
  - [x] Implement `runRetentionPolicy(): Promise<void>`:
    - Call both pruneByAge() and pruneByCount()
    - Log total events pruned
    - Called periodically (e.g., every hour) or on startup
  - [x] [Source: packages/connector/src/agent/event-database.ts lines 531-542 - prune pattern]

- [x] Task 6: Implement Database Lifecycle Methods (AC: 1)
  - [x] Implement `close(): Promise<void>`:
    - Close libSQL client
    - Set client to null
    - Log closure
  - [x] Implement `getEventCount(): Promise<number>`:
    - Return total event count
  - [x] Implement `getDatabaseSize(): Promise<number>`:
    - Return database size in bytes using PRAGMA
  - [x] [Source: packages/connector/src/agent/event-database.ts lines 143-148, 498-522]

- [x] Task 7: Integrate EventStore with TelemetryEmitter (AC: 2)
  - [x] Modify `TelemetryEmitter` constructor to optionally accept EventStore:
    ```typescript
    constructor(
      dashboardUrl: string,
      nodeId: string,
      logger: Logger,
      eventStore?: EventStore
    )
    ```
  - [x] Modify `emit()` method to also write to EventStore if configured:

    ```typescript
    emit(event: TelemetryEvent): void {
      // Existing WebSocket logic...

      // Also persist to EventStore if configured
      if (this._eventStore) {
        this._eventStore.storeEvent(event).catch((error) => {
          this._logger.warn({ error }, 'Failed to store telemetry event');
        });
      }
    }
    ```

  - [x] Add similar logic to other emit methods (emitPacketReceived, etc.)
  - [x] Non-blocking: EventStore failures should not prevent WebSocket emission
  - [x] [Source: packages/connector/src/telemetry/telemetry-emitter.ts lines 401-424]

- [x] Task 8: Create Unit Tests for EventStore (AC: 6)
  - [x] Create file: `packages/connector/src/explorer/event-store.test.ts`
  - [x] Test initialization:
    - Creates database with schema
    - Creates all required indexes
    - Handles :memory: path
  - [x] Test event storage:
    - Stores event with all fields extracted
    - Returns inserted row ID
    - Handles events with missing optional fields (direction, peerId, etc.)
  - [x] Test batch storage:
    - Stores multiple events atomically
    - All events have correct fields
  - [x] Test query API:
    - Returns all events when no filter
    - Filters by eventTypes
    - Filters by time range (since/until)
    - Filters by peerId
    - Filters by packetId
    - Filters by direction
    - Pagination works correctly (limit, offset)
    - Returns count correctly
  - [x] Test retention policy:
    - pruneByAge removes old events
    - pruneByCount keeps only newest events
    - runRetentionPolicy combines both
  - [x] Test edge cases:
    - Empty filter returns all events
    - Query with no results returns empty array
    - Large payload stored and retrieved correctly
  - [x] [Source: docs/architecture/test-strategy-and-standards.md lines 18-60]

- [x] Task 9: Create Integration Test for TelemetryEmitter + EventStore (AC: 2)
  - [x] Create file: `packages/connector/test/integration/telemetry-event-store.test.ts`
  - [x] Test end-to-end flow:
    - Create EventStore with :memory: database
    - Create TelemetryEmitter with EventStore
    - Emit various telemetry events
    - Query EventStore and verify events persisted
    - Verify all indexed fields extracted correctly
  - [x] Test non-blocking behavior:
    - EventStore failure doesn't throw in emit()
    - WebSocket emission continues even if storage fails
  - [x] [Source: docs/architecture/test-strategy-and-standards.md lines 65-133]

- [x] Task 10: Export EventStore from Explorer Module (AC: 1)
  - [x] Create file: `packages/connector/src/explorer/index.ts`
  - [x] Export:
    ```typescript
    export { EventStore, EventStoreConfig, EventQueryFilter, StoredEvent } from './event-store';
    ```
  - [x] [Source: packages/connector/src/agent/index.ts export patterns]

## Dev Notes

### Previous Story Insights

Story 13.8 (Integration Tests) completed the Agent Society Protocol with:

- **AgentEventDatabase** pattern for libSQL integration that this story should follow
- **libSQL client creation**: `createClient({ url: ':memory:' })` or `createClient({ url: 'file:./path' })`
- **Schema with indexes**: Pattern for CREATE TABLE and CREATE INDEX statements
- **Batch operations**: Using `client.batch(statements, 'write')` for atomic transactions
- **Query building**: Dynamic WHERE clause construction with parameterized queries

[Source: docs/stories/13.8.story.md, packages/connector/src/agent/event-database.ts]

Story 13.7 (Agent Configuration Schema) established configuration patterns:

- **Config interfaces** with optional fields and defaults
- **Validation patterns** for configuration values
- **Export patterns** via index.ts barrel files

[Source: docs/stories/13.7.story.md]

### Technical Context

**Event Store Architecture:**

The EventStore serves as the persistence layer for the Explorer UI, storing all telemetry events emitted by the connector for historical browsing:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Telemetry Event Flow                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ConnectorNode ──► TelemetryEmitter ──┬──► WebSocket (Dashboard)        │
│       │                                │                                 │
│       │                                └──► EventStore (libSQL)         │
│       │                                          │                       │
│       │                                          ▼                       │
│       │                                  explorer.db                     │
│       │                                     │                            │
│       │                                     ▼                            │
│       │                             REST API (Story 14.2)               │
│       │                                     │                            │
│       │                                     ▼                            │
│       └────────────────────────────► Explorer UI (Story 14.3+)          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

[Source: docs/prd/epic-14-packet-event-explorer-ui.md lines 40-48]

**Database Schema Design:**

The schema extracts key fields from telemetry events for efficient indexing while preserving the full event JSON for flexibility:

| Column      | Type    | Description                        | Indexed  |
| ----------- | ------- | ---------------------------------- | -------- |
| id          | INTEGER | Auto-incrementing primary key      | Yes (PK) |
| event_type  | TEXT    | Telemetry event type discriminator | Yes      |
| timestamp   | INTEGER | Unix timestamp (milliseconds)      | Yes      |
| node_id     | TEXT    | Connector node ID                  | No       |
| direction   | TEXT    | 'sent' / 'received' / 'internal'   | No       |
| peer_id     | TEXT    | Related peer if applicable         | Yes      |
| packet_id   | TEXT    | ILP packet ID (condition hex)      | Yes      |
| amount      | TEXT    | Amount as string (bigint)          | No       |
| destination | TEXT    | ILP destination address            | No       |
| payload     | TEXT    | Full event JSON                    | No       |

[Source: docs/prd/epic-14-packet-event-explorer-ui.md lines 54-72]

### Data Models

**TelemetryEvent Types (existing):**
[Source: packages/shared/src/types/telemetry.ts]

The TelemetryEvent union type includes 20+ event types that must all be supported:

- ACCOUNT_BALANCE, SETTLEMENT_TRIGGERED, SETTLEMENT_COMPLETED
- AGENT_BALANCE_CHANGED, AGENT_WALLET_FUNDED, AGENT_WALLET_STATE_CHANGED
- PAYMENT_CHANNEL_OPENED, PAYMENT_CHANNEL_BALANCE_UPDATE, PAYMENT_CHANNEL_SETTLED
- XRP_CHANNEL_OPENED, XRP_CHANNEL_CLAIMED, XRP_CHANNEL_CLOSED
- AGENT_CHANNEL_OPENED, AGENT_CHANNEL_PAYMENT_SENT, AGENT_CHANNEL_CLOSED
- WALLET_BALANCE_MISMATCH, SUSPICIOUS_ACTIVITY_DETECTED, RATE_LIMIT_EXCEEDED
- And more...

**Field Extraction Mapping:**

| Event Type                     | direction  | peer_id | packet_id | amount          | destination |
| ------------------------------ | ---------- | ------- | --------- | --------------- | ----------- |
| ACCOUNT_BALANCE                | null       | peerId  | null      | netBalance      | null        |
| SETTLEMENT_TRIGGERED           | null       | peerId  | null      | currentBalance  | null        |
| SETTLEMENT_COMPLETED           | null       | peerId  | null      | settledAmount   | null        |
| PAYMENT_CHANNEL_OPENED         | null       | peerId  | channelId | initialDeposits | null        |
| PAYMENT_CHANNEL_BALANCE_UPDATE | null       | null    | channelId | myTransferred   | null        |
| PAYMENT_CHANNEL_SETTLED        | null       | null    | channelId | null            | null        |
| XRP_CHANNEL_OPENED             | null       | peerId  | channelId | amount          | destination |
| XRP_CHANNEL_CLAIMED            | null       | peerId  | channelId | claimAmount     | null        |
| XRP_CHANNEL_CLOSED             | null       | peerId  | channelId | finalBalance    | null        |
| AGENT_CHANNEL_OPENED           | null       | peerId  | channelId | amount          | null        |
| AGENT_CHANNEL_PAYMENT_SENT     | 'sent'     | null    | channelId | amount          | null        |
| AGENT_CHANNEL_CLOSED           | null       | null    | channelId | null            | null        |
| AGENT_BALANCE_CHANGED          | null       | null    | null      | change          | null        |
| AGENT_WALLET_FUNDED            | null       | null    | null      | null            | null        |
| AGENT_WALLET_STATE_CHANGED     | 'internal' | null    | null      | null            | null        |
| WALLET_BALANCE_MISMATCH        | null       | null    | null      | actualBalance   | null        |
| SUSPICIOUS_ACTIVITY_DETECTED   | null       | null    | null      | null            | null        |
| RATE_LIMIT_EXCEEDED            | null       | null    | null      | null            | null        |

**Note:** The `TelemetryEvent` union type does NOT include `PACKET_RECEIVED`, `PACKET_SENT`, `NODE_STATUS`, or `ROUTE_LOOKUP` events. Those are sent via `TelemetryMessage` through separate emitter methods (`emitPacketReceived()`, `emitPacketSent()`, etc.). Story 14.1 focuses on storing `TelemetryEvent` types via the `emit()` method. Packet event storage may be added in a future story if needed.

[Source: packages/shared/src/types/telemetry.ts, packages/shared/src/types/payment-channel-telemetry.ts]

**Timestamp Format Handling:**

TelemetryEvent types use two different timestamp formats that must be normalized:

| Timestamp Format                        | Event Types                                                                                                              |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| ISO 8601 string (`timestamp: string`)   | ACCOUNT*BALANCE, SETTLEMENT*_, PAYMENT*CHANNEL*_, XRP*CHANNEL*_, AGENT*BALANCE_CHANGED, AGENT_WALLET_FUNDED, FUNDING*_   |
| Unix milliseconds (`timestamp: number`) | AGENT*WALLET_STATE_CHANGED, AGENT_CHANNEL*\*, WALLET_BALANCE_MISMATCH, SUSPICIOUS_ACTIVITY_DETECTED, RATE_LIMIT_EXCEEDED |

The `extractIndexedFields()` helper must normalize both formats to Unix milliseconds (INTEGER) for the database:

```typescript
function normalizeTimestamp(event: TelemetryEvent): number {
  const ts = (event as { timestamp: string | number }).timestamp;
  if (typeof ts === 'number') {
    return ts; // Already Unix ms
  }
  return new Date(ts).getTime(); // ISO 8601 → Unix ms
}
```

[Source: packages/shared/src/types/telemetry.ts lines 126-149, 498-509, 771-788]

### File Locations

**New Files (Story 14.1):**

```
packages/connector/src/explorer/
├── index.ts                    # Module exports
├── event-store.ts              # EventStore class
├── event-store.test.ts         # Unit tests

packages/connector/test/integration/
├── telemetry-event-store.test.ts  # Integration test
```

**Modified Files:**

```
packages/connector/src/telemetry/
├── telemetry-emitter.ts        # Add EventStore integration
```

**Related Existing Files:**

```
packages/connector/src/agent/
├── event-database.ts           # Reference for libSQL patterns

packages/shared/src/types/
├── telemetry.ts                # TelemetryEvent type definitions
```

[Source: docs/architecture/source-tree.md, docs/prd/epic-14-packet-event-explorer-ui.md lines 125-156]

### Testing Requirements

**Test Framework:** Jest 29.7.x with TypeScript support
[Source: docs/architecture/tech-stack.md line 23]

**Unit Test Location:** Co-located at `packages/connector/src/explorer/event-store.test.ts`
[Source: docs/architecture/test-strategy-and-standards.md line 23]

**Required Test Coverage:**

- > 80% line coverage for event-store.ts
- All CRUD operations tested (store, query, delete via retention)
- All filter combinations tested
- Pagination tested
- Error cases tested

**Test Pattern:**
[Source: docs/architecture/test-strategy-and-standards.md lines 36-59]

```typescript
describe('EventStore', () => {
  let eventStore: EventStore;
  let mockLogger: jest.Mocked<Logger>;

  beforeEach(async () => {
    mockLogger = createMockLogger();
    eventStore = new EventStore(
      {
        path: ':memory:',
        maxEventCount: 1000,
        maxAgeMs: 86400000, // 1 day
      },
      mockLogger
    );
    await eventStore.initialize();
  });

  afterEach(async () => {
    await eventStore.close();
  });

  it('should store event with extracted fields', async () => {
    const event: AccountBalanceEvent = {
      type: 'ACCOUNT_BALANCE',
      nodeId: 'connector-a',
      peerId: 'peer-b',
      // ... other fields
    };

    const id = await eventStore.storeEvent(event);

    expect(id).toBeGreaterThan(0);

    const stored = await eventStore.queryEvents({});
    expect(stored).toHaveLength(1);
    expect(stored[0].peer_id).toBe('peer-b');
  });
});
```

### Technical Constraints

**TypeScript Configuration:**

- Strict mode enabled (`strict: true`)
- No `any` types except in test mocks
- Use async/await for all database operations
  [Source: docs/architecture/coding-standards.md lines 38-41]

**Naming Conventions:**

- Files: `event-store.ts` (kebab-case)
- Classes: `EventStore` (PascalCase)
- Interfaces: `EventStoreConfig`, `StoredEvent` (PascalCase)
- Functions: `storeEvent`, `queryEvents` (camelCase)
- Constants: `DEFAULT_MAX_EVENT_COUNT` (UPPER_SNAKE_CASE)
  [Source: docs/architecture/coding-standards.md lines 14-20]

**Non-Blocking Telemetry:**

- EventStore failures MUST NOT throw in TelemetryEmitter
- Use `.catch()` to log errors without propagating
- This matches existing non-blocking telemetry pattern
  [Source: packages/connector/src/telemetry/telemetry-emitter.ts lines 401-424]

**libSQL Dependency:**

- Reuse `@libsql/client` from Epic 13
- Version: 0.14.0
- Already in package.json dependencies
  [Source: docs/architecture/tech-stack.md line 34]

### Default Values

| Config Field  | Default Value | Notes                   |
| ------------- | ------------- | ----------------------- |
| maxEventCount | 1000000       | 1 million events        |
| maxAgeMs      | 604800000     | 7 days in milliseconds  |
| query limit   | 50            | Default pagination size |
| query offset  | 0             | Start from beginning    |

[Source: docs/prd/epic-14-packet-event-explorer-ui.md lines 327-330]

### Dependencies

**Existing Dependencies:**

- `@libsql/client` 0.14.0 - libSQL client (already installed for Epic 13)
- `@m2m/shared` - TelemetryEvent types

**New Imports:**

```typescript
import { createClient, Client } from '@libsql/client';
import { TelemetryEvent } from '@m2m/shared';
import { Logger } from '../utils/logger';
```

[Source: packages/connector/src/agent/event-database.ts lines 1-3]

### Edge Cases and Error Scenarios

**Event Storage:**

- Event with missing optional fields → Store with null for those columns
- Very large payload (e.g., 1MB event) → Should store successfully
- Invalid event type → Store as-is (forward compatibility)

**Query Operations:**

- Empty filter → Return all events (with default limit)
- No matching events → Return empty array
- Invalid time range (since > until) → Return empty array or all events

**Retention Policy:**

- No events to prune → Return 0, no error
- All events expired → Delete all
- Concurrent pruning and storage → libSQL handles transactions

**Database Errors:**

- Connection failure → Log error, don't throw from emit()
- Disk full → Log error, don't throw from emit()
- Query timeout → Log error, return empty result

### Performance Considerations

- **Batch inserts**: Use batch() for multiple events to reduce transaction overhead
- **Indexed queries**: All filter fields have indexes for O(log n) lookups
- **Pagination**: Always use LIMIT/OFFSET to prevent memory issues
- **Background pruning**: Run retention policy periodically, not on every insert
- **<1% overhead**: Event storage should not noticeably impact packet processing

[Source: docs/prd/epic-14-packet-event-explorer-ui.md lines 165, 347]

## Testing

### Test File Locations

- `packages/connector/src/explorer/event-store.test.ts` - Unit tests
- `packages/connector/test/integration/telemetry-event-store.test.ts` - Integration tests

[Source: docs/architecture/test-strategy-and-standards.md line 23]

### Test Framework

Jest 29.7.x with ts-jest for TypeScript support
[Source: docs/architecture/tech-stack.md line 23]

### Test Commands

```bash
# Run EventStore unit tests
npm test -- packages/connector/src/explorer/event-store.test.ts

# Run integration tests
npm test -- packages/connector/test/integration/telemetry-event-store.test.ts

# Run with coverage
npm test -- --coverage packages/connector/src/explorer/

# Run all explorer tests
npm test -- packages/connector/src/explorer/ packages/connector/test/integration/telemetry
```

### Test Coverage Requirements

- > 80% line coverage for event-store.ts
- All CRUD operations tested
- All filter combinations tested
- Retention policy tested
- TelemetryEmitter integration tested
  [Source: docs/architecture/test-strategy-and-standards.md lines 7-9]

### Acceptance Criteria Verification

| AC# | Test Scenario                                       | Verification Method                                    |
| --- | --------------------------------------------------- | ------------------------------------------------------ |
| 1   | EventStore class wraps libSQL with telemetry schema | Test schema creation, table structure, indexes         |
| 2   | TelemetryEmitter writes to EventStore               | Integration test: emit() stores event in database      |
| 3   | Events stored with all indexed fields extracted     | Verify stored event has correct field extraction       |
| 4   | Configurable retention policy                       | Test pruneByAge(), pruneByCount() with various configs |
| 5   | Query API for filtered event retrieval              | Test all filter options and pagination                 |
| 6   | Unit tests cover all CRUD operations                | Verify >80% coverage, all paths tested                 |

---

## Change Log

| Date       | Version | Description                  | Author |
| ---------- | ------- | ---------------------------- | ------ |
| 2026-01-24 | 0.1     | Initial story draft creation | SM     |

---

## Story Wrap Up (Agent Populates After Execution)

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Completion Notes

- Created `packages/connector/src/explorer/event-store.ts` implementing EventStore class with full libSQL integration
- Implemented all 10 tasks including:
  - EventStore class with libSQL schema (events table with 4 indexes)
  - storeEvent() with field extraction for all 18+ TelemetryEvent types
  - storeEvents() batch method using libSQL transactions
  - queryEvents() with filtering by eventTypes, time range, peerId, packetId, direction + pagination
  - countEvents() for pagination UI support
  - Retention policy (pruneByAge, pruneByCount, runRetentionPolicy)
  - Database lifecycle methods (close, getEventCount, getDatabaseSize)
- Integrated EventStore into TelemetryEmitter via optional constructor parameter
- Non-blocking: EventStore failures are caught and logged, never thrown
- Created comprehensive unit tests (48 tests passing)
- Created integration tests for TelemetryEmitter + EventStore (14 tests passing)
- Exported EventStore and types from explorer module index.ts
- All lint and build checks pass

### File List

**New Files:**

- `packages/connector/src/explorer/event-store.ts` - EventStore class implementation
- `packages/connector/src/explorer/event-store.test.ts` - Unit tests (48 tests)
- `packages/connector/src/explorer/index.ts` - Module exports
- `packages/connector/test/integration/telemetry-event-store.test.ts` - Integration tests (14 tests)

**Modified Files:**

- `packages/connector/src/telemetry/telemetry-emitter.ts` - Added EventStore integration

### Change Log

| Date       | Version | Description                  | Author            |
| ---------- | ------- | ---------------------------- | ----------------- |
| 2026-01-24 | 0.1     | Initial story draft creation | SM                |
| 2026-01-24 | 1.0     | Implementation complete      | James (Dev Agent) |

---

## QA Results

### Review Date: 2026-01-24

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall:** Excellent implementation quality. The EventStore class is well-designed, follows established patterns from Epic 13's AgentEventDatabase, and integrates cleanly with TelemetryEmitter. Code is clean, properly documented with JSDoc comments, and adheres to project coding standards.

**Strengths:**

- Clean separation of concerns between EventStore and TelemetryEmitter
- Comprehensive field extraction switch statement covers all 18+ TelemetryEvent types
- Proper timestamp normalization handles both ISO 8601 and Unix ms formats
- Parameterized SQL queries prevent injection vulnerabilities
- Well-structured unit tests follow AAA pattern with descriptive names

**Architecture Alignment:**

- Follows libSQL patterns established in Epic 13 (event-database.ts)
- Module exports via index.ts barrel file (matches project conventions)
- Non-blocking telemetry pattern correctly implemented

### Refactoring Performed

None required. Implementation is clean and follows best practices.

### Compliance Check

- Coding Standards: ✓ (kebab-case files, PascalCase classes, camelCase methods, UPPER_SNAKE_CASE constants)
- Project Structure: ✓ (co-located tests, index.ts exports, correct directories)
- Testing Strategy: ✓ (62 tests passing, >80% coverage expected, integration tests included)
- All ACs Met: ✓ (all 6 acceptance criteria fully implemented and tested)

### Improvements Checklist

- [x] EventStore class wraps libSQL with telemetry schema (event-store.ts:254-627)
- [x] TelemetryEmitter writes to EventStore non-blocking (telemetry-emitter.ts:407-417)
- [x] All 18+ event types have field extraction logic (event-store.ts:136-240)
- [x] Retention policy with pruneByAge and pruneByCount (event-store.ts:527-583)
- [x] Query API with filtering and pagination (event-store.ts:407-520)
- [x] Unit tests cover all CRUD operations (48 tests)
- [x] Integration tests verify end-to-end flow (14 tests)

### Security Review

- ✓ SQL injection protection: All queries use parameterized arguments
- ✓ No console.log usage: Pino logger used throughout
- ✓ No hardcoded credentials or secrets
- ✓ Non-blocking: EventStore failures logged but never thrown

### Performance Considerations

- ✓ 4 database indexes for efficient lookups (event_type, timestamp DESC, packet_id, peer_id)
- ✓ Batch operations use libSQL batch() for atomic transactions
- ✓ Pagination with LIMIT/OFFSET prevents memory issues
- ✓ Background retention policy (caller decides when to run)

### Files Modified During Review

None. No refactoring required.

### Gate Status

Gate: PASS → docs/qa/gates/14.1-explorer-event-store.yml

### Recommended Status

✓ Ready for Done

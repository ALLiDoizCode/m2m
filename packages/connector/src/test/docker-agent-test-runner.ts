/* eslint-disable no-console */
/**
 * Docker Agent Society Test Runner
 *
 * Orchestrates the Agent Society integration test using Docker containers.
 * This script runs inside a container and communicates with agent containers
 * via HTTP API calls.
 *
 * Test Phases:
 * 1. Wait for all agents to be healthy
 * 2. Query agent status and collect pubkeys
 * 3. Configure social graph (hub-and-spoke + ring topology)
 * 4. Deploy AGENT token to Anvil
 * 5. Establish BTP connections between agents
 * 6. Trigger event exchange via broadcast endpoints
 * 7. Verify events were received and stored
 *
 * Environment Variables:
 *   ANVIL_RPC_URL - Anvil RPC endpoint (default: http://anvil:8545)
 *   AGENT_COUNT - Number of agents (default: 5)
 *   LOG_LEVEL - Log level (default: info)
 */

import { ethers } from 'ethers';
import * as http from 'http';

// ============================================
// Types
// ============================================

interface AgentInfo {
  index: number;
  containerId: string;
  httpUrl: string;
  btpUrl: string;
  agentId: string;
  pubkey: string;
  ilpAddress: string;
  evmAddress: string; // EVM wallet address for payment channels
  xrpAddress: string; // XRP wallet address for payment channels
  xrpSecret: string; // XRP wallet secret (for test runner config)
  initialized: boolean;
}

interface TestConfig {
  anvilRpcUrl: string;
  xrplRpcUrl: string;
  xrplWssUrl: string;
  xrpEnabled: boolean;
  evmEnabled: boolean;
  agentCount: number;
  agentBaseHttpPort: number;
  agentBaseBtpPort: number;
  useDockerHostnames: boolean;
}

interface TestResults {
  success: boolean;
  phases: {
    name: string;
    success: boolean;
    duration: number;
    details: string;
  }[];
  summary: string;
}

// Social graph for 5 peers (hub-and-spoke + ring)
const SOCIAL_GRAPH_5_PEERS: Record<number, number[]> = {
  0: [1, 2, 3, 4], // Hub follows all
  1: [0, 2],
  2: [0, 1, 3],
  3: [0, 2, 4],
  4: [0, 3],
};

// ============================================
// HTTP Utilities
// ============================================

function httpGet(url: string): Promise<unknown> {
  return new Promise((resolve, reject) => {
    const req = http.get(url, (res) => {
      let data = '';
      res.on('data', (chunk) => (data += chunk));
      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch {
          resolve(data);
        }
      });
    });
    req.on('error', reject);
    req.setTimeout(10000, () => {
      req.destroy();
      reject(new Error('Request timeout'));
    });
  });
}

function httpPost(url: string, body: unknown, timeoutMs = 30000): Promise<unknown> {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const data = JSON.stringify(body);

    const req = http.request(
      {
        hostname: urlObj.hostname,
        port: urlObj.port,
        path: urlObj.pathname,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(data),
        },
      },
      (res) => {
        let responseData = '';
        res.on('data', (chunk) => (responseData += chunk));
        res.on('end', () => {
          try {
            resolve(JSON.parse(responseData));
          } catch {
            resolve(responseData);
          }
        });
      }
    );

    req.on('error', reject);
    req.setTimeout(timeoutMs, () => {
      req.destroy();
      reject(new Error('Request timeout'));
    });
    req.write(data);
    req.end();
  });
}

async function waitForAgent(url: string, maxRetries = 30): Promise<boolean> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = (await httpGet(`${url}/health`)) as { initialized?: boolean };
      if (response.initialized) {
        return true;
      }
    } catch {
      // Ignore errors, retry
    }
    await sleep(1000);
  }
  return false;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ============================================
// Contract Deployment
// ============================================

const MOCK_ERC20_ABI = [
  'constructor(string _name, string _symbol, uint8 _decimals)',
  'function balanceOf(address) view returns (uint256)',
  'function transfer(address to, uint256 value) returns (bool)',
  'function approve(address spender, uint256 value) returns (bool)',
];

const MOCK_ERC20_BYTECODE =
  '0x6080604052346200034a5762000a5e803803806200001d816200034e565b9283398101906060818303126200034a5780516001600160401b03908181116200034a57836200004f91840162000374565b602093848401518381116200034a576040916200006e91860162000374565b9301519160ff83168093036200034a5781519381851162000268575f54946001938487811c971680156200033f575b8888101462000249578190601f97888111620002ec575b50889088831160011462000288575f926200027c575b50505f19600383901b1c191690841b175f555b8051918211620002685782548381811c911680156200025d575b87821014620002495785811162000201575b5085948211600114620001a05793819293945f9262000194575b50505f19600383901b1c191690821b1790555b8060ff196002541617600255604d81116200018057600a0a90620f42409180830292830403620001805760049082600355335f525260405f20556040516106799081620003e58239f35b634e487b7160e01b5f52601160045260245ffd5b015190505f8062000123565b601f19821694835f52865f20915f5b88888210620001ec5750508385969710620001d3575b505050811b01905562000136565b01515f1960f88460031b161c191690555f8080620001c5565b828401518555938601939283019201620001af565b835f52865f208680850160051c8201928986106200023f575b0160051c019084905b8281106200023357505062000109565b5f815501849062000223565b925081926200021a565b634e487b7160e01b5f52602260045260245ffd5b90607f1690620000f7565b634e487b7160e01b5f52604160045260245ffd5b015190505f80620000ca565b90869350601f198316915f80528a5f20925f5b8c828210620002d55750508411620002bc575b505050811b015f55620000dd565b01515f1960f88460031b161c191690555f8080620002ae565b8385015186558a979095019493840193016200029b565b9091505f8052885f208880850160051c8201928b861062000335575b918891869594930160051c01915b82811062000326575050620000b4565b5f815585945088910162000316565b9250819262000308565b96607f16966200009d565b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176200026857604052565b919080601f840112156200034a5782516001600160401b0381116200026857602090620003aa601f8201601f191683016200034e565b928184528282870101116200034a575f5b818110620003d05750825f9394955001015290565b8581018301518482018401528201620003bb56fe6080604090808252600480361015610015575f80fd5b5f3560e01c91826306fdde031461048a57508163095ea7b31461041c57816318160ddd146103fe57816323b872dd146102e1578163313ce567146102c057816370a082311461028b57816395d89b4114610169578163a9059cbb146100cf575063dd62ed3e14610083575f80fd5b346100cb57806003193601126100cb5760209061009e6105a6565b6100a66105bc565b9060018060a01b038091165f5260058452825f2091165f528252805f20549051908152f35b5f80fd5b82346100cb57806003193601126100cb576020916100eb6105a6565b60243590335f5282855261010482855f205410156105d2565b335f52828552835f20610118838254610615565b905560018060a01b031691825f528452825f20610136828254610636565b905582519081527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef843392a35160018152f35b82346100cb575f3660031901126100cb578051905f60018054908160011c9060018316928315610281575b602093848410811461026e5783885290811561025257506001146101fc575b505050829003601f01601f191682019267ffffffffffffffff8411838510176101e957508291826101e592528261055f565b0390f35b604190634e487b7160e01b5f525260245ffd5b60015f908152929350837fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b83851061023e57505050508301018480806101b3565b805488860183015293019284908201610228565b60ff1916878501525050151560051b84010190508480806101b3565b602289634e487b7160e01b5f525260245ffd5b91607f1691610194565b82346100cb5760203660031901126100cb576020916001600160a01b036102b06105a6565b165f528252805f20549051908152f35b82346100cb575f3660031901126100cb5760209060ff600254169051908152f35b82346100cb5760603660031901126100cb576102fb6105a6565b916103046105bc565b9260443560018060a01b0380921691825f5260209584875261032b83875f205410156105d2565b835f5260058752855f20335f52875282865f2054106103c2579186917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93855f52868452875f2061037d848254610615565b90551694855f528252855f20610394828254610636565b9055835f5260058252855f20335f528252855f206103b3828254610615565b90558551908152a35160018152f35b855162461bcd60e51b81528086018890526016602482015275496e73756666696369656e7420616c6c6f77616e636560501b6044820152606490fd5b82346100cb575f3660031901126100cb576020906003549051908152f35b82346100cb57806003193601126100cb576020906104386105a6565b602435335f5260058452825f209160018060a01b031691825f52845280835f205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b83346100cb575f3660031901126100cb575f805460018160011c9060018316928315610555575b602093848410811461026e57838852908115610252575060011461050157505050829003601f01601f191682019267ffffffffffffffff8411838510176101e957508291826101e592528261055f565b5f808052929350837f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5635b83851061054157505050508301018480806101b3565b80548886018301529301928490820161052b565b91607f16916104b1565b602080825282518183018190529093925f5b82811061059257505060409293505f838284010152601f8019910116010190565b818101860151848201604001528501610571565b600435906001600160a01b03821682036100cb57565b602435906001600160a01b03821682036100cb57565b156105d957565b60405162461bcd60e51b8152602060048201526014602482015273496e73756666696369656e742062616c616e636560601b6044820152606490fd5b9190820391821161062257565b634e487b7160e01b5f52601160045260245ffd5b919082018092116106225756fea26469706673582212205933fde19cbb69f2cccc4f75287d18e1bba74e57ee228dc52a228763eb68bac664736f6c63430008180033';

// TokenNetworkRegistry ABI and bytecode (compiled from contracts/src/TokenNetworkRegistry.sol)
// This bytecode includes the TokenNetwork contract since registry deploys TokenNetwork via new TokenNetwork()
const TOKEN_NETWORK_REGISTRY_ABI = [
  'constructor()',
  'function createTokenNetwork(address token) external returns (address)',
  'function getTokenNetwork(address token) external view returns (address)',
  'event TokenNetworkCreated(address indexed token, address indexed tokenNetwork)',
];

const TOKEN_NETWORK_REGISTRY_BYTECODE =
  '0x60808060405234610078573315610063575f8054336001600160a01b03198216811783556040519290916001600160a01b0316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3612f94908161007d8239f35b631e4fbdf760e01b81525f6004820152602490fd5b5f80fdfe608060408181526004918236101562000016575f80fd5b5f3560e01c9081630fabd9e714620006e157508063306275be14620006755780633f4ba83a146200060357806351fb012d14620005e05780635c975abb14620005b9578063715018a6146200055e5780638456cb5914620004fa5780638da5cb5b14620004d1578063981005a2146200049157806398f44a1214620003035780639e45511914620002c3578063cdfb2b4e1462000275578063d6b0f484146200022a578063d84c1b3814620001bb578063daf9c21014620001785763f2fde38b14620000e0575f80fd5b346200017457602036600319011262000174576001600160a01b038235818116939192908490036200017457620001166200071f565b83156200015e5750505f54826bffffffffffffffffffffffff60a01b8216175f55167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b905f6024925191631e4fbdf760e01b8352820152fd5b5f80fd5b509034620001745760203660031901126200017457356001600160a01b038116919082900362000174576020915f526003825260ff815f20541690519015158152f35b509034620001745760203660031901126200017457356001600160a01b03811691908290036200017457620001ef6200071f565b815f5260036020525f20600160ff198254161790557f6a65f90b1a644d2faac467a21e07e50e3f8fa5846e26231d30ae79a417d3d2625f80a2005b823462000174575f3660031901126200017457620002476200071f565b805460ff191690557f212c6e1d3045c9581ef0adf2504dbb1d137f52f38162ccf77a16c69d14eba5c35f80a1005b823462000174575f3660031901126200017457620002926200071f565b805460ff191660011790557fe5e5846f783279948f6ec5faad38318cde86fe5be7ea845ede56d62f16c374345f80a1005b509034620001745760203660031901126200017457356001600160a01b03818116929183900362000174576020925f5260018352815f2054169051908152f35b5034620001745760209182600319360112620001745780356001600160a01b03818116939184900362000174576200033a6200074b565b8315620004835760ff835416806200046d575b6200045f57835f526001855280825f205416620004495781516127f28082019082821067ffffffffffffffff831117620004365760609183916200076d833987815269d3c21bcecceda1000000898201526301e13380868201520301905ff080156200042c57169182156200041e57508190835f5260018552805f206bffffffffffffffffffffffff60a01b908382825416179055825f526002865284825f209182541617905551927ff11a7558a113d9627989c5edf26cbd19143b7375248e621c8e30ac9e0847dc3f5f80a38152f35b905163111139af60e01b8152fd5b82513d5f823e3d90fd5b604186634e487b7160e01b5f525260245ffd5b509160249251916307f60e1360e01b8352820152fd5b50516307c241ad60e51b8152fd5b50835f526003855260ff825f205416156200034d565b5051630f58058360e11b8152fd5b509034620001745760203660031901126200017457356001600160a01b03818116929183900362000174576020925f5260028352815f2054169051908152f35b503462000174575f36600319011262000174575f5490516001600160a01b039091168152602090f35b503462000174575f366003190112620001745760207f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258916200053b6200071f565b620005456200074b565b5f805460ff60a01b1916600160a01b17905551338152a1005b3462000174575f36600319011262000174576200057a6200071f565b5f80546001600160a01b0319811682556001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b503462000174575f366003190112620001745760209060ff5f5460a01c1690519015158152f35b503462000174575f366003190112620001745760ff602092541690519015158152f35b503462000174575f3660031901126200017457620006206200071f565b5f549160ff8360a01c1615620006675760ff60a01b1983165f5581513381527f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa90602090a1005b9051638dfc202b60e01b8152fd5b509034620001745760203660031901126200017457356001600160a01b03811691908290036200017457620006a96200071f565b815f5260036020525f2060ff1981541690557fdd2e6d9f52cbe8f695939d018b7d4a216dc613a669876163ac548b916489d9175f80a2005b905082346200017457602036600319011262000174576001600160a01b039035818116939084900362000174576020935f52600184525f2054168152f35b5f546001600160a01b031633036200073357565b60405163118cdaa760e01b8152336004820152602490fd5b60ff5f5460a01c166200075a57565b60405163d93c066560e01b8152600490fdfe6101c034620002a0576001600160401b0390601f620027f238819003918201601f191683019190848311848410176200028c578160609285926040958652833981010312620002a05781516001600160a01b0392908381168103620002a057826020830151920151928051906200007682620002a4565b600c825260208201906b546f6b656e4e6574776f726b60a01b82528051976200009f89620002a4565b6001895260208901603160f81b815260017f9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f0055620000dd85620002c0565b93610120948552620000ef8b6200048a565b95610140968752519020998a60e05251902061010099818b524660a05283519160208301917f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f83528584015260608301524660808301523060a083015260a0825260c0820192828410908411176200028c57828452815190206080523060c05233156200027657505060028054610100600160a81b0319811633600881811b610100600160a81b03169290921790935592519891921c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36101609283526101809384526101a09485526121c0968762000632883960805187611d50015260a05187611e0b015260c05187611d1a015260e05187611d9f01525186611dc501525185610ed201525184610efb0152518381816102cc0152818161030001528181610369015281816109da01528181610a0e01528181610ae101528181610d290152611291015251828181610e9a0152611340015251818181611149015261172e0152f35b631e4fbdf760e01b82525f60c490910152602490fd5b634e487b7160e01b5f52604160045260245ffd5b5f80fd5b604081019081106001600160401b038211176200028c57604052565b8051602090818110156200035a5750601f825111620002fb5780825192015190808310620002ed57501790565b825f19910360031b1b161790565b90604051809263305a27a960e01b82528060048301528251908160248401525f935b82851062000340575050604492505f838284010152601f80199101168101030190fd5b84810182015186860160440152938101938593506200031d565b906001600160401b0382116200028c575f54926001938481811c911680156200047f575b838210146200046b57601f811162000435575b5081601f8411600114620003cf57509282939183925f94620003c3575b50501b915f199060031b1c1916175f5560ff90565b015192505f80620003ae565b919083601f1981165f8052845f20945f905b888383106200041a575050501062000401575b505050811b015f5560ff90565b01515f1960f88460031b161c191690555f8080620003f4565b858701518855909601959485019487935090810190620003e1565b5f805284601f845f20920160051c820191601f860160051c015b8281106200045f57505062000391565b5f81550185906200044f565b634e487b7160e01b5f52602260045260245ffd5b90607f16906200037e565b805160209081811015620005165750601f825111620004b75780825192015190808310620002ed57501790565b90604051809263305a27a960e01b82528060048301528251908160248401525f935b828510620004fc575050604492505f838284010152601f80199101168101030190fd5b8481018201518686016044015293810193859350620004d9565b9192916001600160401b0381116200028c5760019182548381811c9116801562000626575b828210146200046b57601f8111620005f0575b5080601f83116001146200058c5750819293945f9262000580575b50505f19600383901b1c191690821b17905560ff90565b015190505f8062000569565b90601f19831695845f52825f20925f905b888210620005d85750508385969710620005bf575b505050811b01905560ff90565b01515f1960f88460031b161c191690555f8080620005b2565b8087859682949686015181550195019301906200059d565b835f5283601f835f20920160051c820191601f850160051c015b8281106200061a5750506200054e565b5f81550184906200060a565b90607f16906200053b56fe60a06040526004361015610011575f80fd5b5f3560e01c806324f453d1146117b85780632e9637e0146116da578063365473c61461149357806336bcdb80146111d55780633f4ba83a1461116c5780634c8b9fc8146111325780635a104746146111155780635c975abb146110f3578063715018a6146110945780637a7ebd7b1461101d5780638456cb5914610fc457806384b0196e14610ebd57806387d9871714610e835780638da5cb5b14610e57578063a79a2c7814610de2578063b62e9e9b14610bac578063bf32097c14610a96578063c76701c3146106b6578063db96157d1461069a578063f2fde38b14610603578063fa29f75214610398578063fc0c546a146103545763fd3d319914610116575f80fd5b34610350576020806003193601126103505760043590610134611bf7565b61013c611c26565b815f526004815260405f20906001820191825492600260ff851661015f81611b37565b0361033e576101746002830154835490611b93565b421061032c578492835f52600580825260405f2095600160a01b600190038060048701541697885f52845260405f205492875f5280855260405f20895f52855260405f206001015496885f5281865260405f208a5f52865260405f206004015491895f52808752828160405f209301968588541693845f52895260405f20600401549384938d5f52808b5260405f20825f528b5260405f20549d5f528a5260405f20905f52895260405f20600101549a61022d91611bea565b9061023791611bea565b9061024191611b93565b98899861024d91611bea565b9061025791611bea565b9061026191611b93565b94859260ff19166003179055851515976040977ff94fb5c0628a82dc90648e8dc5e983f632633b0d26603d64e8cc042ca0790aa4996102f9575b5050816102c2575b5050508351928352820152a260015f8051602061216b83398151915255005b806102f1935416907f000000000000000000000000000000000000000000000000000000000000000016611c99565b5f82816102a3565b61032591837f000000000000000000000000000000000000000000000000000000000000000016611c99565b5f8661029b565b6040516385986a1760e01b8152600490fd5b60405163f806e9d960e01b8152600490fd5b5f80fd5b34610350575f366003190112610350576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610350576103a636611ac7565b6103b1929192611bf7565b6103b9611c26565b815f526020926004845260405f2060018101600160ff8254166103db81611b37565b0361033e5760048201546001600160a01b039081163381148015806105f3575b6105e157156105db575080600584015416935b868151036105c95780889151928282019681885199604085019687519b606087019788519760800197885191604051608052608051019e8f936080519561045495611ba0565b039a601f199b8c8101608051526080519061046e91611a4f565b60805151902061047d90611c44565b9061048791611e31565b61049391949294611e6b565b1691829116036105b757885f5260058a5260405f20815f528a52600360405f200154875111156105a5576001978a6105456002968c61055195815f526005855260405f20335f5285528960405f200160ff199e8f8254161790558c51825f526005865260405f20825f528652600360405f2001558251915f526005855260405f20905f528452600460405f20015551955194516040519586938401978891606093918352602083015260408201520190565b03908101835282611a4f565b5190209482541617905560024291015551926040519384528301527fd5957384eab5a0d19edc418bd26b5a30bf723c432b8ec504bb3153db8d8f921760403393a360015f8051602061216b83398151915255005b604051633ab3447f60e11b8152600490fd5b604051638baa579f60e01b8152600490fd5b604051631cfb46fb60e21b8152600490fd5b9361040e565b6040516350a2e21f60e11b8152600490fd5b50826005860154163314156103fb565b346103505760203660031901126103505761061c6119cf565b610624611c6a565b6001600160a01b038181169182156106825760028054610100600160a81b03198116600893841b610100600160a81b031617909155901c167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b604051631e4fbdf760e01b81525f6004820152602490fd5b34610350575f366003190112610350576020604051610e108152f35b34610350576101a03660031901126103505760a0366023190112610350576040516106e0816119fb565b602435815260443560208201526064356040820152608435606082015260a435608082015267ffffffffffffffff9060c43582811161035057610727903690600401611a71565b60a03660e31901126103505760405192610740846119fb565b60e43584526101043560208501526101243560408501526101443560608501526101643560808501526101843590811161035057610782903690600401611a71565b61078a611bf7565b610792611c26565b6004355f52600460205260405f20600181015491600160ff84166107b581611b37565b0361033e57600435855114801590610a89575b6105c9576020850151602087015103610a77576108736108409161083761087c9661083289518a61082a602082015161081c6040840151936080606082015191015190604051958694602086019889611ba0565b03601f198101835282611a4f565b519020611c44565b611e31565b90949194611e6b565b610832885160208a015161082a60408c01519161081c8d6080606082015191015190604051958694602086019889611ba0565b90959195611e6b565b60018060a01b03918280600483015416921696828814908160058401978587808b5416809d14921683610a6d575b8315610a4f575b505050156105b7576004355f52600560205260405f20845f5260205260405f2054906004355f52600560205260405f20855f5260205260405f2060010154986004355f52600560205260405f208b5f5260205260405f20549a6004355f52600560205260405f20905f5260205260405f2060010154935f149961095d60019561096761096d9661096260039f9761096297604099610a3a578961095d910151998a920151978894611bea565b611bea565b611b93565b9d611bea565b96879560ff1916179101558580610a07575b5050816109d0575b50505060405191825260208201527ffb2f4bc0fb2e0f1001f78d15e81a2e1981f262d31e8bd72309e26cc63bf7bb02604060043592a260015f8051602061216b83398151915255005b806109ff935416907f000000000000000000000000000000000000000000000000000000000000000016611c99565b828181610987565b610a3391837f000000000000000000000000000000000000000000000000000000000000000016611c99565b858561097f565b908961095d910151998a920151978894611bea565b9192509082610a63575b50508a85816108b1565b149050848b610a59565b8c811493506108aa565b60405163e112ed9160e01b8152600490fd5b50600435865114156107c8565b3461035057604036600319011261035057610aaf6119e5565b610ab7611c6a565b60ff6002541615610b9a576040516370a0823160e01b8152306004820152906001600160a01b03907f00000000000000000000000000000000000000000000000000000000000000008216602084602481845afa938415610b8f575f94610b57575b508382610b2592611c99565b60405192835216907f668ede93de2924e11e5554ea95dd0839a40ddf58c1f04b209fde0dc8298a75c8602060043592a3005b909193506020813d602011610b87575b81610b7460209383611a4f565b8101031261035057519290610b25610b19565b3d9150610b67565b6040513d5f823e3d90fd5b60405163dcdde9dd60e01b8152600490fd5b346103505760803660031901126103505760443560043560243567ffffffffffffffff60643581811161035057610be7903690600401611a71565b93610bf0611bf7565b610bf8611c26565b835f526020916004835260405f2095600160ff8189015416610c1981611b37565b0361033e5760048701546001600160a01b03973391891691821491821580610dd2575b6105e157899215610dca575060050154165b60405190608082019382851090851117610db65761087389938660608695610cd5986040528c8152338b8201528b60408201520152610832604051898101907f3a313e46ac850ea3171e09169e25e22c511e6ca6e78188b6007f76435ce3dcad82528c60408201523360608201528b60808201528960a082015260a0815261082a81611a17565b169116036105b757835f526005825260405f20335f52825260405f20600381019081548311156105a5576001810180549182871115610da457548611610d9257610d4e610d23879384611bea565b809933907f000000000000000000000000000000000000000000000000000000000000000016611c99565b55556040519384528301527fe3dc7feadbd67893939d3a39c2e030d48267965cc32664a5ad07a8dd18bf16fd60403393a360015f8051602061216b83398151915255005b604051634d6416c960e01b8152600490fd5b60405163179b08df60e31b8152600490fd5b634e487b7160e01b5f52604160045260245ffd5b915050610c4e565b5089600583015416331415610c3c565b3461035057604036600319011261035057610dfb6119e5565b6004355f52600560205260405f209060018060a01b03165f5260205260a060405f2080549060018101549060ff600282015416600460038301549201549260405194855260208501521515604084015260608301526080820152f35b34610350575f3660031901126103505760025460405160089190911c6001600160a01b03168152602090f35b34610350575f3660031901126103505760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610350575f36600319011261035057610ef67f0000000000000000000000000000000000000000000000000000000000000000611ef6565b610f1f7f0000000000000000000000000000000000000000000000000000000000000000612017565b60405160208082019282841067ffffffffffffffff851117610db657916020610f798594610f6b97966040525f8452604051978897600f60f81b895260e0858a015260e0890190611b55565b908782036040890152611b55565b914660608701523060808701525f60a087015285830360c087015251918281520192915f5b828110610fad57505050500390f35b835185528695509381019392810192600101610f9e565b34610350575f36600319011261035057610fdc611c6a565b610fe4611c26565b600160ff1960025416176002557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b34610350576020366003190112610350576004355f52600460205260c060405f2080549060ff60018201541690600281015460038201549060018060a01b03600581600486015416940154169360405195865261107981611b37565b602086015260408501526060840152608083015260a0820152f35b34610350575f366003190112610350576110ac611c6a565b60028054610100600160a81b031981169091555f9060081c6001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b34610350575f36600319011261035057602060ff600254166040519015158152f35b34610350575f366003190112610350576020600354604051908152f35b34610350575f3660031901126103505760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610350575f36600319011261035057611184611c6a565b60025460ff8116156111c35760ff19166002557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b604051638dfc202b60e01b8152600490fd5b34610350576060366003190112610350576004356111f16119e5565b906044356111fd611bf7565b611205611c26565b815f526020906004825260405f2090600160ff818401541661122681611b37565b0361033e5760048201546001600160a01b03958616959290831686141590839082611482575b50506105e157835f526005835260405f20855f52835260405f205490818110611470578161127991611bea565b6040516370a0823160e01b80825230600483015290937f000000000000000000000000000000000000000000000000000000000000000016918585602481865afa948515610b8f575f95611441575b50604051906323b872dd60e01b5f523360045230602452604452855f60648180875af160015f5114811615611422575b816040525f6060521561140c5750849060246040518094819382523060048301525afa908115610b8f575f916113dd575b5061133d9261133791611bea565b90611b93565b907f000000000000000000000000000000000000000000000000000000000000000082116113cb577f0346e981e2bfa2366dc2307a8f1fa24779830a01121b1275fe565c6b98bb4d3491835f526005825260405f20855f52825260405f2055825f526005815260405f20845f52815260405f2054604051908152a360015f8051602061216b83398151915255005b604051630d5befc560e31b8152600490fd5b90508381813d8311611405575b6113f48183611a4f565b81010312610350575161133d611329565b503d6113ea565b635274afe760e01b815260048101839052602490fd5b600181151661143857833b15153d1516166112f8565b503d5f823e3d90fd5b9094508581813d8311611469575b6114598183611a4f565b81010312610350575193886112c8565b503d61144f565b60405163070f6eed60e11b8152600490fd5b60050154168614159050828761124c565b34610350576114a136611ac7565b91906114ab611bf7565b6114b3611c26565b815f526020926004845260405f2091600260ff6001850154166114d581611b37565b0361033e57835f5260059283865260405f20335f52865260ff600260405f200154166116c95760048101546001600160a01b03919082169033821415806116ba575b6105e15761152b6002820154825490611b93565b4210156116a857858391885f52818a5260405f20845f528a5260ff600260405f200154165f1461169e575050505b858351036105c957825193878401958651928460408701938451958c60608a019a8b519a6080019a8b51906040519a8b948501956115979487611ba0565b0396601f199788810182526115ac9082611a4f565b5190206115b890611c44565b906115c291611e31565b6115ce91949294611e6b565b1694859116036105b757875f5280895260405f20845f528952600360405f200154875111156105a557611656938751895f52828b5260405f20825f528b52600360405f200155825191895f528a5260405f20905f528952600460405f2001555193519251926105456040519485928a8401978891606093918352602083015260408201520190565b5190209051926040519384528301527fa74d11e70725a216b7835e4eccc704900e38620c7254d1b5fe3811f064a4244660403393a360015f8051602061216b83398151915255005b0154169050611559565b604051637222b06b60e11b8152600490fd5b50828682015416331415611517565b6040516298465360e81b8152600490fd5b34610350576020366003190112610350576004356116f6611bf7565b6116fe611c26565b805f52600460205260405f20600181018054600160ff821661171f81611b37565b0361033e5761175360038401547f000000000000000000000000000000000000000000000000000000000000000090611b93565b42106117a65760029060ff19161790556002429101557fa3d9abb459f23bad7e2b9ad2f9bb6f56d3b2d3e3958c2e97fae66e35fcae56de6020604051428152a260015f8051602061216b83398151915255005b60405163d56b7c9760e01b8152600490fd5b34610350576040366003190112610350576117d16119cf565b602435906117dd611bf7565b6117e5611c26565b6001600160a01b039080821680156105e1578033146105e157610e1084106119bd573310156119b657335b6003549260405194602095868101838516946bffffffffffffffffffffffff19809160601b1682528487169660601b16603483015286604883015260488252608082019167ffffffffffffffff9281811084821117610db657604052519020955f1981146119a257600101600355855f526004875260ff600160405f2001541661189981611b37565b611990576040519160c0830191821183831017610db65786937f448d27f1fe12f92a2070111296e68fd6ef0a01c0e05bf5819eda0dbcf267bf3d9389936040528281528381019160018352600560408301925f84526060810142815260808201948b865260a08301968d88528b5f5260048a5260405f209351845560018401905161192381611b37565b61192c81611b37565b60ff801983541691161790555160028301555160038201558260048201945116936bffffffffffffffffffffffff60a01b94858254161790550192511690825416179055604051908152a460015f8051602061216b83398151915255604051908152f35b604051630ec0f14960e01b8152600490fd5b634e487b7160e01b5f52601160045260245ffd5b3390611810565b60405163579d2e9960e01b8152600490fd5b600435906001600160a01b038216820361035057565b602435906001600160a01b038216820361035057565b60a0810190811067ffffffffffffffff821117610db657604052565b60c0810190811067ffffffffffffffff821117610db657604052565b6040810190811067ffffffffffffffff821117610db657604052565b90601f8019910116810190811067ffffffffffffffff821117610db657604052565b81601f820112156103505780359067ffffffffffffffff8211610db65760405192611aa6601f8401601f191660200185611a4f565b8284526020838301011161035057815f926020809301838601378301015290565b60e0600319820112610350576004359160a060231983011261035057604051611aef816119fb565b602435815260443560208201526064356040820152608435606082015260a43560808201529160c4359067ffffffffffffffff821161035057611b3491600401611a71565b90565b60041115611b4157565b634e487b7160e01b5f52602160045260245ffd5b91908251928382525f5b848110611b7f575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201611b5f565b919082018092116119a257565b919260a093969594919660c08401977f716df000aa2a680ba0826f710c1641c4d9fbef21b69b995e39fe4dd74da178cb855260208501526040840152606083015260808201520152565b919082039182116119a257565b5f8051602061216b8339815191526002815414611c145760029055565b604051633ee5aeb560e01b8152600490fd5b60ff60025416611c3257565b60405163d93c066560e01b8152600490fd5b604290611c4f611d17565b906040519161190160f01b8352600283015260228201522090565b60025460081c6001600160a01b03163303611c8157565b60405163118cdaa760e01b8152336004820152602490fd5b60405163a9059cbb60e01b5f9081526001600160a01b039384166004526024949094529260209060448180855af160015f5114811615611cf8575b8360405215611ce257505050565b635274afe760e01b835216600482015260249150fd5b6001811516611d0e57813b15153d151616611cd4565b833d5f823e3d90fd5b307f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161480611e08575b15611d72577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a08152611e0281611a17565b51902090565b507f00000000000000000000000000000000000000000000000000000000000000004614611d49565b8151919060418303611e6157611e5a9250602082015190606060408401519301515f1a906120e8565b9192909190565b50505f9160029190565b611e7481611b37565b80611e7d575050565b611e8681611b37565b60018103611ea05760405163f645eedf60e01b8152600490fd5b611ea981611b37565b60028103611eca5760405163fce698f760e01b815260048101839052602490fd5b80611ed6600392611b37565b14611ede5750565b602490604051906335e2f38360e21b82526004820152fd5b60ff8114611f345760ff811690601f8211611f225760405191611f1883611a33565b8252602082015290565b604051632cd44ac360e21b8152600490fd5b506040515f8054906001908260011c6001841692831561200d575b6020948583108514611ff9578287528694908115611fd95750600114611f7e575b5050611b3492500382611a4f565b5f8080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56395935091905b818310611fc1575050611b3493508201015f80611f70565b85548784018501529485019486945091830191611fa9565b915050611b3494925060ff191682840152151560051b8201015f80611f70565b634e487b7160e01b5f52602260045260245ffd5b90607f1690611f4f565b60ff81146120395760ff811690601f8211611f225760405191611f1883611a33565b506040515f60018054918260011c600184169283156120de575b6020948583108514611ff9578287528694908115611fd95750600114612081575050611b3492500382611a4f565b9093915060015f527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6935f915b8183106120c6575050611b3493508201015f80611f70565b855487840185015294850194869450918301916120ae565b90607f1690612053565b91907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0841161215f579160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa15610b8f575f516001600160a01b0381161561215557905f905f90565b505f906001905f90565b5050505f916003919056fe9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00a26469706673582212203c0fa53b2d411f91f12b4b3ce8f0f2930b7f442eaed6263673d4dc9e3154c32164736f6c63430008180033a2646970667358221220f9a16d1c8c247d79d6b932f2221d96bb4097553a447fbd3342f2bcddd7eb699464736f6c63430008180033';

// Note: TokenNetwork ABI is defined in agent-server.ts for channel operations

// Contract deployment results
interface ContractDeployment {
  tokenAddress: string;
  registryAddress: string;
  tokenNetworkAddress: string;
}

async function deployAgentToken(
  deployer: ethers.Wallet,
  nonce: number
): Promise<{ address: string; nextNonce: number }> {
  const factory = new ethers.ContractFactory(MOCK_ERC20_ABI, MOCK_ERC20_BYTECODE, deployer);
  const token = await factory.deploy('Agent Token', 'AGENT', 18, { nonce });
  await token.waitForDeployment();
  return { address: token.target as string, nextNonce: nonce + 1 };
}

async function deployTokenNetworkRegistry(
  deployer: ethers.Wallet,
  nonce: number
): Promise<{ address: string; nextNonce: number }> {
  const factory = new ethers.ContractFactory(
    TOKEN_NETWORK_REGISTRY_ABI,
    TOKEN_NETWORK_REGISTRY_BYTECODE,
    deployer
  );
  const registry = await factory.deploy({ nonce });
  await registry.waitForDeployment();
  return { address: registry.target as string, nextNonce: nonce + 1 };
}

async function createTokenNetwork(
  deployer: ethers.Wallet,
  registryAddress: string,
  tokenAddress: string,
  nonce: number
): Promise<{ address: string; nextNonce: number }> {
  const registry = new ethers.Contract(registryAddress, TOKEN_NETWORK_REGISTRY_ABI, deployer);
  const createFn = registry.getFunction('createTokenNetwork');
  const tx = await createFn(tokenAddress, { nonce });
  const receipt = await tx.wait();

  // Parse TokenNetworkCreated event to get the TokenNetwork address
  const event = receipt.logs.find((log: ethers.Log) => {
    try {
      const parsed = registry.interface.parseLog({
        topics: log.topics as string[],
        data: log.data,
      });
      return parsed?.name === 'TokenNetworkCreated';
    } catch {
      return false;
    }
  });

  if (!event) {
    throw new Error('TokenNetworkCreated event not found');
  }

  const parsed = registry.interface.parseLog({
    topics: event.topics as string[],
    data: event.data,
  });
  return { address: parsed?.args[1] as string, nextNonce: nonce + 1 }; // tokenNetwork address
}

async function fundAgentWallet(
  deployer: ethers.Wallet,
  tokenAddress: string,
  recipientAddress: string,
  amount: bigint,
  nonce: number
): Promise<number> {
  const token = new ethers.Contract(tokenAddress, MOCK_ERC20_ABI, deployer);
  const transferFn = token.getFunction('transfer');
  const tx = await transferFn(recipientAddress, amount, { nonce });
  await tx.wait();
  return nonce + 1;
}

// ============================================
// Test Runner Class
// ============================================

class DockerAgentTestRunner {
  private config: TestConfig;
  private agents: AgentInfo[] = [];
  private results: TestResults;
  private contracts: ContractDeployment | null = null;
  private agentChannels: Map<string, string[]> = new Map(); // agentId -> channelIds

  constructor() {
    // Detect if running inside Docker or from host
    const isDocker = process.env.RUNNING_IN_DOCKER === 'true';

    this.config = {
      anvilRpcUrl:
        process.env.ANVIL_RPC_URL || (isDocker ? 'http://anvil:8545' : 'http://localhost:8545'),
      xrplRpcUrl:
        process.env.XRPL_RPC_URL || (isDocker ? 'http://rippled:5005' : 'http://localhost:5005'),
      xrplWssUrl:
        process.env.XRPL_WSS_URL || (isDocker ? 'ws://rippled:6006' : 'ws://localhost:6006'),
      xrpEnabled: process.env.XRP_ENABLED !== 'false', // Enabled by default
      evmEnabled: process.env.EVM_ENABLED !== 'false', // Enabled by default
      agentCount: parseInt(process.env.AGENT_COUNT || '5', 10),
      agentBaseHttpPort: isDocker ? 8080 : 8100, // Inside Docker all agents use 8080, from host use mapped ports
      agentBaseBtpPort: isDocker ? 3000 : 3100,
      useDockerHostnames: isDocker,
    };

    this.results = {
      success: false,
      phases: [],
      summary: '',
    };
  }

  private getAgentHttpUrl(index: number): string {
    if (this.config.useDockerHostnames) {
      return `http://agent-${index}:${this.config.agentBaseHttpPort}`;
    }
    return `http://localhost:${this.config.agentBaseHttpPort + index}`;
  }

  private getAgentBtpUrl(index: number): string {
    if (this.config.useDockerHostnames) {
      return `ws://agent-${index}:${this.config.agentBaseBtpPort}`;
    }
    return `ws://localhost:${this.config.agentBaseBtpPort + index}`;
  }

  // Get BTP URL for inter-container communication (always uses Docker hostnames)
  private getAgentBtpUrlForDocker(index: number): string {
    return `ws://agent-${index}:3000`;
  }

  async run(): Promise<TestResults> {
    console.log('\n========================================');
    console.log('Docker Agent Society Integration Test');
    console.log('========================================\n');
    console.log(`Configuration:`);
    console.log(`  Anvil URL: ${this.config.anvilRpcUrl}`);
    console.log(`  XRPL RPC URL: ${this.config.xrplRpcUrl}`);
    console.log(`  XRPL WSS URL: ${this.config.xrplWssUrl}`);
    console.log(`  EVM Enabled: ${this.config.evmEnabled}`);
    console.log(`  XRP Enabled: ${this.config.xrpEnabled}`);
    console.log(`  Agent Count: ${this.config.agentCount}`);
    console.log(`  Docker Hostnames: ${this.config.useDockerHostnames}`);
    console.log('');

    try {
      // Phase 1: Wait for agents
      await this.runPhase('Wait for Agents', async () => {
        return await this.waitForAllAgents();
      });

      // Phase 2: Collect agent info
      await this.runPhase('Collect Agent Info', async () => {
        return await this.collectAgentInfo();
      });

      // Phase 3: Configure social graph
      await this.runPhase('Configure Social Graph', async () => {
        return await this.configureSocialGraph();
      });

      // Phase 4: Deploy EVM Contracts (Token, Registry, TokenNetwork)
      if (this.config.evmEnabled) {
        await this.runPhase('Deploy EVM Contracts', async () => {
          return await this.deployContracts();
        });

        // Phase 5: Fund Agent EVM Wallets
        await this.runPhase('Fund Agent EVM Wallets', async () => {
          return await this.fundAgentWallets();
        });
      }

      // Phase 6: Fund XRP Accounts
      if (this.config.xrpEnabled) {
        await this.runPhase('Fund XRP Accounts', async () => {
          return await this.fundXRPAccounts();
        });

        // Phase 7: Configure Agents with XRP
        await this.runPhase('Configure Agents XRP', async () => {
          return await this.configureAgentsXRP();
        });
      }

      // Update peer addresses with EVM/XRP info now that all addresses are known
      await this.runPhase('Update Peer Addresses', async () => {
        return await this.updatePeerAddresses();
      });

      // Phase 8: Establish BTP connections
      await this.runPhase('Establish BTP Connections', async () => {
        return await this.establishConnections();
      });

      // Phase 9: Open EVM Payment Channels
      if (this.config.evmEnabled) {
        await this.runPhase('Open EVM Payment Channels', async () => {
          return await this.openPaymentChannels();
        });
      }

      // Phase 10: Open XRP Payment Channels
      if (this.config.xrpEnabled) {
        await this.runPhase('Open XRP Payment Channels', async () => {
          return await this.openXRPChannels();
        });
      }

      // Phase 11: Broadcast events
      await this.runPhase('Broadcast Events', async () => {
        return await this.broadcastEvents();
      });

      // Phase 12: Verify results
      await this.runPhase('Verify Results', async () => {
        return await this.verifyResults();
      });

      // Phase 13: Verify EVM Payment Channel State
      if (this.config.evmEnabled) {
        await this.runPhase('Verify EVM Channels', async () => {
          return await this.verifyPaymentChannels();
        });
      }

      // Phase 14: Verify XRP Payment Channel State
      if (this.config.xrpEnabled) {
        await this.runPhase('Verify XRP Channels', async () => {
          return await this.verifyXRPChannels();
        });
      }

      // Phase 15: Settle EVM Channels
      if (this.config.evmEnabled) {
        await this.runPhase('Settle EVM Channels', async () => {
          return await this.settleEVMChannels();
        });
      }

      // Phase 16: Claim XRP Channels
      if (this.config.xrpEnabled) {
        await this.runPhase('Claim XRP Channels', async () => {
          return await this.claimXRPChannels();
        });
      }

      // Phase 17: Verify EVM Settlement On-Chain
      if (this.config.evmEnabled) {
        await this.runPhase('Verify EVM Settlement', async () => {
          return await this.verifyEVMSettlement();
        });
      }

      // Phase 18: Verify XRP Settlement On-Chain
      if (this.config.xrpEnabled) {
        await this.runPhase('Verify XRP Settlement', async () => {
          return await this.verifyXRPSettlement();
        });
      }

      // Phase 19: Report Agent Balances
      await this.runPhase('Report Agent Balances', async () => {
        return await this.reportAgentBalances();
      });

      // Calculate overall success
      this.results.success = this.results.phases.every((p) => p.success);
      this.results.summary = this.results.success
        ? `All ${this.results.phases.length} phases passed`
        : `${this.results.phases.filter((p) => p.success).length}/${this.results.phases.length} phases passed`;
    } catch (error) {
      this.results.success = false;
      this.results.summary = `Test failed: ${(error as Error).message}`;
    }

    // Print results
    this.printResults();

    return this.results;
  }

  private async runPhase(name: string, fn: () => Promise<string>): Promise<void> {
    const start = Date.now();
    console.log(`\n[Phase] ${name}...`);

    try {
      const details = await fn();
      const duration = Date.now() - start;
      this.results.phases.push({ name, success: true, duration, details });
      console.log(`  ✓ ${details} (${duration}ms)`);
    } catch (error) {
      const duration = Date.now() - start;
      const details = (error as Error).message;
      this.results.phases.push({ name, success: false, duration, details });
      console.log(`  ✗ ${details} (${duration}ms)`);
      throw error;
    }
  }

  // ============================================
  // Phase Implementations
  // ============================================

  private async waitForAllAgents(): Promise<string> {
    const promises = [];
    for (let i = 0; i < this.config.agentCount; i++) {
      const url = this.getAgentHttpUrl(i);
      promises.push(waitForAgent(url));
    }

    const results = await Promise.all(promises);
    const readyCount = results.filter((r) => r).length;

    if (readyCount !== this.config.agentCount) {
      throw new Error(`Only ${readyCount}/${this.config.agentCount} agents are ready`);
    }

    return `${readyCount} agents ready`;
  }

  private async collectAgentInfo(): Promise<string> {
    this.agents = [];

    for (let i = 0; i < this.config.agentCount; i++) {
      const httpUrl = this.getAgentHttpUrl(i);
      const btpUrl = this.getAgentBtpUrl(i);

      const status = (await httpGet(`${httpUrl}/status`)) as {
        agentId: string;
        pubkey: string;
        ilpAddress: string;
        evmAddress: string;
        xrpAddress?: string;
        initialized: boolean;
      };

      this.agents.push({
        index: i,
        containerId: `agent-${i}`,
        httpUrl,
        btpUrl,
        agentId: status.agentId,
        pubkey: status.pubkey,
        ilpAddress: status.ilpAddress,
        evmAddress: status.evmAddress || '', // May not be available initially
        xrpAddress: status.xrpAddress || '', // Will be set after XRP funding
        xrpSecret: '', // Will be set after XRP funding
        initialized: status.initialized,
      });
    }

    return `Collected info for ${this.agents.length} agents`;
  }

  private async configureSocialGraph(): Promise<string> {
    const topology =
      this.config.agentCount <= 5
        ? SOCIAL_GRAPH_5_PEERS
        : this.generateSocialGraph(this.config.agentCount);

    let totalFollows = 0;

    for (const [peerIndexStr, followIndices] of Object.entries(topology)) {
      const peerIndex = parseInt(peerIndexStr, 10);
      if (peerIndex >= this.config.agentCount) continue;

      const agent = this.agents[peerIndex];
      if (!agent) continue;

      for (const followIndex of followIndices) {
        if (followIndex >= this.config.agentCount) continue;
        const followedAgent = this.agents[followIndex];
        if (!followedAgent) continue;

        // Use Docker hostname for BTP URL so containers can reach each other
        const btpUrlForDocker = this.getAgentBtpUrlForDocker(followIndex);
        await httpPost(`${agent.httpUrl}/follows`, {
          pubkey: followedAgent.pubkey,
          ilpAddress: followedAgent.ilpAddress,
          evmAddress: followedAgent.evmAddress || undefined,
          xrpAddress: followedAgent.xrpAddress || undefined,
          petname: followedAgent.agentId,
          btpUrl: btpUrlForDocker,
        });

        totalFollows++;
      }
    }

    return `Configured ${totalFollows} follow relationships`;
  }

  private generateSocialGraph(n: number): Record<number, number[]> {
    const graph: Record<number, number[]> = {};

    for (let i = 0; i < n; i++) {
      const follows: number[] = [];
      graph[i] = follows;

      if (i === 0) {
        // Hub follows all
        for (let j = 1; j < n; j++) {
          follows.push(j);
        }
      } else {
        // All follow hub
        follows.push(0);

        // Ring: follow adjacent peers
        const prev = i === 1 ? n - 1 : i - 1;
        const next = i === n - 1 ? 1 : i + 1;

        if (prev !== 0) follows.push(prev);
        if (next !== 0) follows.push(next);
      }
    }

    return graph;
  }

  private async deployContracts(): Promise<string> {
    // Anvil default deployer private key (pre-funded with 10000 ETH)
    const ANVIL_PRIVATE_KEY = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
    const provider = new ethers.JsonRpcProvider(this.config.anvilRpcUrl);

    // Create a single deployer wallet and manage nonces explicitly
    const deployer = new ethers.Wallet(ANVIL_PRIVATE_KEY, provider);
    let nonce = await provider.getTransactionCount(deployer.address);

    // Deploy AGENT token
    const tokenResult = await deployAgentToken(deployer, nonce);
    nonce = tokenResult.nextNonce;
    console.log(`    AGENT token deployed at ${tokenResult.address}`);

    // Deploy TokenNetworkRegistry
    const registryResult = await deployTokenNetworkRegistry(deployer, nonce);
    nonce = registryResult.nextNonce;
    console.log(`    TokenNetworkRegistry deployed at ${registryResult.address}`);

    // Create TokenNetwork for AGENT token
    const tokenNetworkResult = await createTokenNetwork(
      deployer,
      registryResult.address,
      tokenResult.address,
      nonce
    );
    console.log(`    TokenNetwork deployed at ${tokenNetworkResult.address}`);

    this.contracts = {
      tokenAddress: tokenResult.address,
      registryAddress: registryResult.address,
      tokenNetworkAddress: tokenNetworkResult.address,
    };

    return `Contracts deployed: Token=${tokenResult.address.slice(0, 10)}..., TokenNetwork=${tokenNetworkResult.address.slice(0, 10)}...`;
  }

  private async fundAgentWallets(): Promise<string> {
    if (!this.contracts) {
      throw new Error('Contracts not deployed');
    }

    const ANVIL_PRIVATE_KEY = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
    const provider = new ethers.JsonRpcProvider(this.config.anvilRpcUrl);

    // Create a single deployer wallet and manage nonces explicitly
    const deployer = new ethers.Wallet(ANVIL_PRIVATE_KEY, provider);
    let nonce = await provider.getTransactionCount(deployer.address);

    // Fund amount per agent: 10,000 AGENT tokens (18 decimals)
    const fundAmount = ethers.parseUnits('10000', 18);
    let fundedCount = 0;

    // Agents are always inside Docker, so they always use Docker network hostnames
    // to reach other services (anvil, rippled, other agents)
    const anvilRpcUrlForAgents = 'http://anvil:8545';

    for (const agent of this.agents) {
      // Configure agent with EVM settings first
      try {
        await httpPost(`${agent.httpUrl}/configure-evm`, {
          anvilRpcUrl: anvilRpcUrlForAgents,
          tokenNetworkAddress: this.contracts.tokenNetworkAddress,
          agentTokenAddress: this.contracts.tokenAddress,
        });
      } catch (error) {
        console.log(
          `    Warning: Failed to configure EVM for ${agent.agentId}: ${(error as Error).message}`
        );
      }

      // Get agent's EVM address
      const status = (await httpGet(`${agent.httpUrl}/status`)) as {
        evmAddress?: string;
      };

      if (!status.evmAddress) {
        console.log(`    Warning: Agent ${agent.agentId} has no EVM address`);
        continue;
      }

      agent.evmAddress = status.evmAddress;

      // Fund the agent with ETH for gas fees (1 ETH each)
      const ethAmount = ethers.parseEther('1');
      const ethTx = await deployer.sendTransaction({
        to: agent.evmAddress,
        value: ethAmount,
        nonce: nonce,
      });
      await ethTx.wait();
      nonce++;

      // Fund the agent with AGENT tokens
      nonce = await fundAgentWallet(
        deployer,
        this.contracts.tokenAddress,
        agent.evmAddress,
        fundAmount,
        nonce
      );

      fundedCount++;
      console.log(
        `    Funded ${agent.agentId} (${status.evmAddress.slice(0, 10)}...) with 1 ETH + 10,000 AGENT`
      );
    }

    return `Funded ${fundedCount} agent wallets with ETH + AGENT tokens`;
  }

  private async openPaymentChannels(): Promise<string> {
    if (!this.contracts) {
      throw new Error('Contracts not deployed');
    }

    const topology =
      this.config.agentCount <= 5
        ? SOCIAL_GRAPH_5_PEERS
        : this.generateSocialGraph(this.config.agentCount);

    let channelCount = 0;
    const errors: string[] = [];

    for (const [peerIndexStr, followIndices] of Object.entries(topology)) {
      const peerIndex = parseInt(peerIndexStr, 10);
      if (peerIndex >= this.config.agentCount) continue;

      const agent = this.agents[peerIndex];
      if (!agent || !agent.evmAddress) continue;

      for (const followIndex of followIndices) {
        if (followIndex >= this.config.agentCount) continue;
        const targetAgent = this.agents[followIndex];
        if (!targetAgent || !targetAgent.evmAddress) continue;

        try {
          // Call agent HTTP API to open payment channel
          const result = (await httpPost(`${agent.httpUrl}/channels/open`, {
            peerEvmAddress: targetAgent.evmAddress,
            depositAmount: '1000000000000000000000', // 1000 AGENT tokens (18 decimals)
          })) as { channelId: string; success: boolean };

          if (result.success && result.channelId) {
            // Track channel
            const existing = this.agentChannels.get(agent.agentId) || [];
            existing.push(result.channelId);
            this.agentChannels.set(agent.agentId, existing);
            channelCount++;
          }
        } catch (error) {
          // Channel opening is optional, just log and continue
          errors.push(`${agent.agentId} -> ${targetAgent.agentId}: ${(error as Error).message}`);
        }
      }
    }

    if (errors.length > 0) {
      console.log(
        `    Channel opening errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    return `Opened ${channelCount} payment channels`;
  }

  private async establishConnections(): Promise<string> {
    // Each agent connects to the agents it follows
    let connectionCount = 0;

    for (const agent of this.agents) {
      const follows = (await httpGet(`${agent.httpUrl}/follows`)) as {
        follows: Array<{ ilpAddress: string }>;
      };

      for (const follow of follows.follows) {
        const targetAgent = this.agents.find((a) => a.ilpAddress === follow.ilpAddress);
        if (targetAgent) {
          try {
            // Use Docker hostname for BTP URL so containers can reach each other
            const btpUrlForDocker = this.getAgentBtpUrlForDocker(targetAgent.index);
            await httpPost(`${agent.httpUrl}/connect`, {
              peerId: targetAgent.agentId,
              btpUrl: btpUrlForDocker,
            });
            connectionCount++;
          } catch (error) {
            console.log(
              `    Warning: Failed to connect ${agent.agentId} -> ${targetAgent.agentId}`
            );
          }
        }
      }
    }

    return `Established ${connectionCount} BTP connections`;
  }

  private async broadcastEvents(): Promise<string> {
    let totalSent = 0;
    let totalFailed = 0;
    const rounds = 10;

    for (let round = 0; round < rounds; round++) {
      for (const agent of this.agents) {
        try {
          const result = (await httpPost(`${agent.httpUrl}/broadcast`, {
            kind: 1,
            content: `Hello from ${agent.agentId} (round ${round + 1})!`,
            tags: [],
          })) as { sent: number; failed: number };

          totalSent += result.sent;
          totalFailed += result.failed;
        } catch (error) {
          console.log(
            `    Warning: Broadcast failed for ${agent.agentId}: ${(error as Error).message}`
          );
        }
      }

      // Wait between rounds for propagation
      if (round < rounds - 1) {
        await sleep(500);
      }
    }

    return `Sent ${totalSent} events over ${rounds} rounds (${totalFailed} failed)`;
  }

  private async verifyResults(): Promise<string> {
    // Wait a bit for events to propagate
    await sleep(2000);

    let totalStored = 0;
    const agentStats: string[] = [];

    for (const agent of this.agents) {
      const status = (await httpGet(`${agent.httpUrl}/status`)) as {
        storedEventCount: number;
        eventsReceived: number;
      };

      totalStored += status.storedEventCount;
      agentStats.push(`${agent.agentId}: ${status.storedEventCount} events`);
    }

    console.log(`    Event distribution: ${agentStats.join(', ')}`);

    // Each connection should result in at least one event
    const topology =
      this.config.agentCount <= 5
        ? SOCIAL_GRAPH_5_PEERS
        : this.generateSocialGraph(this.config.agentCount);
    let expectedConnections = 0;
    for (const followIndices of Object.values(topology)) {
      expectedConnections += (followIndices as number[]).filter(
        (i) => i < this.config.agentCount
      ).length;
    }

    if (totalStored < expectedConnections) {
      throw new Error(`Expected at least ${expectedConnections} stored events, got ${totalStored}`);
    }

    return `Verified ${totalStored} events stored (expected >= ${expectedConnections})`;
  }

  private async verifyPaymentChannels(): Promise<string> {
    let totalChannels = 0;
    let totalDeposits = 0n;
    const agentStats: string[] = [];

    for (const agent of this.agents) {
      try {
        const channelsResult = (await httpGet(`${agent.httpUrl}/channels`)) as {
          channels: Array<{
            channelId: string;
            peerAddress: string;
            deposit: string;
            status: string;
          }>;
        };

        const channels = channelsResult.channels || [];
        totalChannels += channels.length;

        for (const ch of channels) {
          totalDeposits += BigInt(ch.deposit || '0');
        }

        if (channels.length > 0) {
          agentStats.push(`${agent.agentId}: ${channels.length} channels`);
        }
      } catch (error) {
        // Channels endpoint may not be available - skip
        console.log(`    Warning: Could not query channels for ${agent.agentId}`);
      }
    }

    if (agentStats.length > 0) {
      console.log(`    Channel distribution: ${agentStats.join(', ')}`);
    }

    const depositInTokens = ethers.formatUnits(totalDeposits, 18);
    return `Verified ${totalChannels} channels with ${depositInTokens} AGENT deposited`;
  }

  // ============================================
  // XRP Payment Channel Methods
  // ============================================

  /**
   * Fund XRP accounts from genesis account in standalone rippled
   */
  private async fundXRPAccounts(): Promise<string> {
    // Genesis account for rippled standalone mode
    const GENESIS_SECRET = 'snoPBrXtMeMyMHUVTgbuqAfg1SUTb';
    const XRP_FUND_AMOUNT = '10000000000'; // 10,000 XRP in drops

    let fundedCount = 0;
    const errors: string[] = [];

    for (const agent of this.agents) {
      try {
        // Generate a wallet for this agent using rippled's wallet_propose
        // Use default key_type (secp256k1) to match xrpl.js Wallet.fromSeed() default
        const walletResponse = (await this.xrplRpcRequest('wallet_propose', {})) as {
          result: {
            account_id: string;
            master_seed: string;
            public_key: string;
          };
        };

        const xrpAddress = walletResponse.result.account_id;
        const xrpSecret = walletResponse.result.master_seed;

        // Update agent info
        agent.xrpAddress = xrpAddress;
        agent.xrpSecret = xrpSecret;

        // Get genesis account sequence
        const accountInfo = (await this.xrplRpcRequest('account_info', {
          account: 'rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh',
          ledger_index: 'validated',
        })) as { result: { account_data: { Sequence: number } } };

        const sequence = accountInfo.result.account_data.Sequence;

        // Create and sign payment transaction
        const tx = {
          TransactionType: 'Payment',
          Account: 'rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh',
          Destination: xrpAddress,
          Amount: XRP_FUND_AMOUNT,
          Sequence: sequence,
        };

        const signResponse = (await this.xrplRpcRequest('sign', {
          secret: GENESIS_SECRET,
          tx_json: tx,
        })) as { result: { tx_blob: string } };

        // Submit the transaction
        const submitResponse = (await this.xrplRpcRequest('submit', {
          tx_blob: signResponse.result.tx_blob,
        })) as { result: { engine_result: string } };

        if (
          submitResponse.result.engine_result === 'tesSUCCESS' ||
          submitResponse.result.engine_result === 'terQUEUED'
        ) {
          // Close ledger to confirm
          await this.xrplRpcRequest('ledger_accept', {});
          await sleep(500);

          fundedCount++;
          console.log(`    Funded ${agent.agentId} XRP account: ${xrpAddress.slice(0, 10)}...`);
        } else {
          errors.push(`${agent.agentId}: ${submitResponse.result.engine_result}`);
        }
      } catch (error) {
        errors.push(`${agent.agentId}: ${(error as Error).message}`);
      }
    }

    if (errors.length > 0) {
      console.log(
        `    Funding errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    return `Funded ${fundedCount} XRP accounts with 10,000 XRP each`;
  }

  /**
   * Configure agents with XRP credentials
   */
  private async configureAgentsXRP(): Promise<string> {
    let configuredCount = 0;
    const errors: string[] = [];

    // Agents are always inside Docker, so they always use Docker network hostnames
    const xrplWssUrlForAgents = 'ws://rippled:6006';

    for (const agent of this.agents) {
      if (!agent.xrpSecret) {
        errors.push(`${agent.agentId}: No XRP secret available`);
        continue;
      }

      try {
        const result = (await httpPost(`${agent.httpUrl}/configure-xrp`, {
          xrpWssUrl: xrplWssUrlForAgents,
          xrpAccountSecret: agent.xrpSecret,
          xrpNetwork: 'standalone',
        })) as { success: boolean; xrpAddress?: string };

        if (result.success) {
          configuredCount++;
          if (result.xrpAddress) {
            agent.xrpAddress = result.xrpAddress;
          }
        } else {
          errors.push(`${agent.agentId}: Configuration failed`);
        }
      } catch (error) {
        errors.push(`${agent.agentId}: ${(error as Error).message}`);
      }
    }

    if (errors.length > 0) {
      console.log(
        `    Config errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    return `Configured ${configuredCount} agents with XRP credentials`;
  }

  /**
   * Re-send follow configurations with complete EVM/XRP addresses
   * so that peer connections have address info for channel balance tracking.
   */
  private async updatePeerAddresses(): Promise<string> {
    const topology =
      this.config.agentCount <= 5
        ? SOCIAL_GRAPH_5_PEERS
        : this.generateSocialGraph(this.config.agentCount);

    let updatedCount = 0;

    for (const [peerIndexStr, followIndices] of Object.entries(topology)) {
      const peerIndex = parseInt(peerIndexStr, 10);
      if (peerIndex >= this.config.agentCount) continue;

      const agent = this.agents[peerIndex];
      if (!agent) continue;

      for (const followIndex of followIndices) {
        if (followIndex >= this.config.agentCount) continue;
        const followedAgent = this.agents[followIndex];
        if (!followedAgent) continue;

        const btpUrlForDocker = this.getAgentBtpUrlForDocker(followIndex);
        await httpPost(`${agent.httpUrl}/follows`, {
          pubkey: followedAgent.pubkey,
          ilpAddress: followedAgent.ilpAddress,
          evmAddress: followedAgent.evmAddress || undefined,
          xrpAddress: followedAgent.xrpAddress || undefined,
          petname: followedAgent.agentId,
          btpUrl: btpUrlForDocker,
        });

        updatedCount++;
      }
    }

    return `Updated ${updatedCount} peer addresses with EVM/XRP info`;
  }

  /**
   * Open XRP payment channels between connected peers
   */
  private async openXRPChannels(): Promise<string> {
    // Advance the ledger to ensure all funded accounts are visible
    try {
      await this.xrplRpcRequest('ledger_accept', {});
    } catch {
      // Ignore if ledger_accept fails
    }

    const topology =
      this.config.agentCount <= 5
        ? SOCIAL_GRAPH_5_PEERS
        : this.generateSocialGraph(this.config.agentCount);

    let channelCount = 0;
    const errors: string[] = [];
    const XRP_CHANNEL_AMOUNT = '1000000000'; // 1,000 XRP in drops

    for (const [peerIndexStr, followIndices] of Object.entries(topology)) {
      const peerIndex = parseInt(peerIndexStr, 10);
      if (peerIndex >= this.config.agentCount) continue;

      const agent = this.agents[peerIndex];
      if (!agent || !agent.xrpAddress) continue;

      for (const followIndex of followIndices) {
        if (followIndex >= this.config.agentCount) continue;
        const targetAgent = this.agents[followIndex];
        if (!targetAgent || !targetAgent.xrpAddress) continue;

        try {
          // Call agent HTTP API to open XRP payment channel
          const result = (await httpPost(`${agent.httpUrl}/xrp-channels/open`, {
            destination: targetAgent.xrpAddress,
            amount: XRP_CHANNEL_AMOUNT,
            settleDelay: 3600, // 1 hour
          })) as { channelId?: string; success: boolean; error?: string };

          if (result.success && result.channelId) {
            channelCount++;
            console.log(
              `    Opened XRP channel: ${agent.agentId} -> ${targetAgent.agentId} (${result.channelId.slice(0, 10)}...)`
            );
          } else {
            errors.push(
              `${agent.agentId} -> ${targetAgent.agentId}: ${result.error || 'Unknown error'}`
            );
          }
        } catch (error) {
          errors.push(`${agent.agentId} -> ${targetAgent.agentId}: ${(error as Error).message}`);
        }
      }
    }

    if (errors.length > 0) {
      console.log(
        `    XRP channel errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    return `Opened ${channelCount} XRP payment channels`;
  }

  /**
   * Verify XRP payment channel state
   */
  private async verifyXRPChannels(): Promise<string> {
    let totalChannels = 0;
    let totalAmount = 0n;
    const agentStats: string[] = [];

    for (const agent of this.agents) {
      try {
        const channelsResult = (await httpGet(`${agent.httpUrl}/xrp-channels`)) as {
          channels: Array<{
            channelId: string;
            destination: string;
            amount: string;
            balance: string;
            status: string;
          }>;
        };

        const channels = channelsResult.channels || [];
        totalChannels += channels.length;

        for (const ch of channels) {
          totalAmount += BigInt(ch.amount || '0');
        }

        if (channels.length > 0) {
          agentStats.push(`${agent.agentId}: ${channels.length} XRP channels`);
        }
      } catch (error) {
        // XRP channels endpoint may not be available - skip
        console.log(`    Warning: Could not query XRP channels for ${agent.agentId}`);
      }
    }

    if (agentStats.length > 0) {
      console.log(`    XRP channel distribution: ${agentStats.join(', ')}`);
    }

    // Convert drops to XRP for display
    const totalXRP = Number(totalAmount) / 1000000;
    return `Verified ${totalChannels} XRP channels with ${totalXRP.toFixed(2)} XRP total`;
  }

  // ============================================
  // Settlement Phase Methods
  // ============================================

  /**
   * Phase 15: Settle EVM channels via cooperative settle
   */
  private async settleEVMChannels(): Promise<string> {
    let settledCount = 0;
    let totalSettled = 0n;
    const errors: string[] = [];

    for (const [agentId] of this.agentChannels) {
      const agent = this.agents.find((a) => a.agentId === agentId);
      if (!agent) continue;

      // Get agent's channels to find peer and balances
      const channelsResult = (await httpGet(`${agent.httpUrl}/channels`)) as {
        channels: Array<{
          channelId: string;
          peerAddress: string;
          deposit: string;
          status: string;
          nonce: number;
          transferredAmount: string;
        }>;
      };

      for (const ch of channelsResult.channels) {
        if (ch.status !== 'opened') continue;

        try {
          const transferredAmount = ch.transferredAmount;
          const nonce = Math.max(ch.nonce, 1);

          // Agent A signs proof with their transferred amount
          const proofA = (await httpPost(`${agent.httpUrl}/channels/sign-proof`, {
            channelId: ch.channelId,
            nonce,
            transferredAmount,
          })) as { signature: string; signer: string };

          // Find peer agent by EVM address
          const peerAgent = this.agents.find(
            (a) => a.evmAddress.toLowerCase() === ch.peerAddress.toLowerCase()
          );
          if (!peerAgent) {
            errors.push(`Peer not found for channel ${ch.channelId.slice(0, 10)}...`);
            continue;
          }

          // Peer signs proof with 0 transferred (unidirectional)
          const proofB = (await httpPost(`${peerAgent.httpUrl}/channels/sign-proof`, {
            channelId: ch.channelId,
            nonce,
            transferredAmount: '0',
          })) as { signature: string; signer: string };

          // Call cooperative settle (use longer timeout - tx.wait() polling can be slow)
          const zeroHash = '0x' + '0'.repeat(64);
          const settleResult = (await httpPost(
            `${agent.httpUrl}/channels/cooperative-settle`,
            {
              channelId: ch.channelId,
              proof1: {
                channelId: ch.channelId,
                nonce,
                transferredAmount,
                lockedAmount: 0,
                locksRoot: zeroHash,
              },
              sig1: proofA.signature,
              proof2: {
                channelId: ch.channelId,
                nonce,
                transferredAmount: '0',
                lockedAmount: 0,
                locksRoot: zeroHash,
              },
              sig2: proofB.signature,
            },
            120000 // 120s timeout for on-chain settlement
          )) as { success: boolean; txHash?: string; error?: string };

          if (settleResult.success) {
            settledCount++;
            totalSettled += BigInt(transferredAmount);
            console.log(
              `    Settled channel ${ch.channelId.slice(0, 10)}... (${transferredAmount} transferred)`
            );
          } else {
            errors.push(`${ch.channelId.slice(0, 10)}...: ${settleResult.error}`);
          }

          // Small delay between settlements to let nonce sync
          await sleep(500);
        } catch (error) {
          errors.push(`${ch.channelId.slice(0, 10)}...: ${(error as Error).message}`);
        }
      }
    }

    if (errors.length > 0) {
      console.log(
        `    Settlement errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    const settledTokens = ethers.formatUnits(totalSettled, 18);
    return `Settled ${settledCount} EVM channels, ${settledTokens} AGENT tokens transferred`;
  }

  /**
   * Phase 16: Claim XRP payment channels
   */
  private async claimXRPChannels(): Promise<string> {
    let claimedCount = 0;
    let totalClaimed = 0n;
    const errors: string[] = [];

    for (const agent of this.agents) {
      try {
        const channelsResult = (await httpGet(`${agent.httpUrl}/xrp-channels`)) as {
          channels: Array<{
            channelId: string;
            destination: string;
            amount: string;
            balance: string;
            status: string;
          }>;
        };

        for (const ch of channelsResult.channels) {
          if (ch.status !== 'open' || ch.balance === '0') continue;

          try {
            const claimResult = (await httpPost(`${agent.httpUrl}/xrp-channels/claim`, {
              channelId: ch.channelId,
            })) as {
              success: boolean;
              claimedAmount?: string;
              txHash?: string;
              error?: string;
            };

            if (claimResult.success) {
              claimedCount++;
              totalClaimed += BigInt(claimResult.claimedAmount || '0');
              console.log(
                `    Claimed XRP channel ${ch.channelId.slice(0, 10)}... (${claimResult.claimedAmount} drops)`
              );
            } else {
              errors.push(`${ch.channelId.slice(0, 10)}...: ${claimResult.error}`);
            }
          } catch (error) {
            errors.push(`${ch.channelId.slice(0, 10)}...: ${(error as Error).message}`);
          }
        }
      } catch {
        // Skip agents without XRP channels
      }
    }

    if (errors.length > 0) {
      console.log(
        `    XRP claim errors: ${errors.slice(0, 3).join('; ')}${errors.length > 3 ? '...' : ''}`
      );
    }

    const totalXRP = Number(totalClaimed) / 1000000;
    return `Claimed ${claimedCount} XRP channels, ${totalXRP.toFixed(2)} XRP claimed`;
  }

  /**
   * Phase 17: Verify EVM settlement on-chain
   */
  private async verifyEVMSettlement(): Promise<string> {
    if (!this.contracts) {
      throw new Error('Contracts not deployed');
    }

    const provider = new ethers.JsonRpcProvider(this.config.anvilRpcUrl);
    const TOKEN_NETWORK_ABI = [
      'function channels(bytes32) external view returns (uint256 settlementTimeout, uint8 state, uint256 closedAt, uint256 openedAt, address participant1, address participant2)',
    ];
    const tokenNetwork = new ethers.Contract(
      this.contracts.tokenNetworkAddress,
      TOKEN_NETWORK_ABI,
      provider
    );

    let verifiedCount = 0;
    let totalChannels = 0;

    for (const [, channelIds] of this.agentChannels) {
      for (const channelId of channelIds) {
        totalChannels++;
        try {
          const channelsFn = tokenNetwork.getFunction('channels');
          const channelInfo = await channelsFn(channelId);
          const state = channelInfo[1]; // uint8 state
          if (state === 3n) {
            // Settled
            verifiedCount++;
          } else {
            console.log(
              `    Channel ${channelId.slice(0, 10)}... state: ${state} (expected 3/Settled)`
            );
          }
        } catch (error) {
          console.log(
            `    Failed to query channel ${channelId.slice(0, 10)}...: ${(error as Error).message}`
          );
        }
      }
    }

    return `Verified ${verifiedCount}/${totalChannels} EVM channels settled on-chain`;
  }

  /**
   * Phase 18: Verify XRP settlement on-chain
   */
  private async verifyXRPSettlement(): Promise<string> {
    let verifiedCount = 0;
    let totalChannels = 0;

    for (const agent of this.agents) {
      try {
        const channelsResult = (await httpGet(`${agent.httpUrl}/xrp-channels`)) as {
          channels: Array<{
            channelId: string;
            balance: string;
            status: string;
          }>;
        };

        for (const ch of channelsResult.channels) {
          if (ch.balance === '0') continue;
          totalChannels++;

          try {
            // Query rippled for the channel on-chain state
            const ledgerEntry = (await this.xrplRpcRequest('ledger_entry', {
              payment_channel: ch.channelId,
              ledger_index: 'validated',
            })) as {
              result: {
                node?: {
                  Balance: string;
                };
              };
            };

            if (ledgerEntry.result?.node?.Balance && ledgerEntry.result.node.Balance !== '0') {
              verifiedCount++;
            } else {
              console.log(
                `    Channel ${ch.channelId.slice(0, 10)}... on-chain balance: ${ledgerEntry.result?.node?.Balance || 'unknown'}`
              );
            }
          } catch (error) {
            console.log(
              `    Failed to query XRP channel ${ch.channelId.slice(0, 10)}...: ${(error as Error).message}`
            );
          }
        }
      } catch {
        // Skip agents without XRP channels
      }
    }

    return `Verified ${verifiedCount}/${totalChannels} XRP channels with on-chain balance updates`;
  }

  /**
   * Phase 19: Report agent balances (wallets + channels) for visibility
   */
  private async reportAgentBalances(): Promise<string> {
    console.log('');
    console.log('    ┌─────────────────────────────────────────────────────────────────────┐');
    console.log('    │                        Agent Balance Report                         │');
    console.log('    ├──────────┬──────────────┬──────────────┬──────────────┬──────────────┤');
    console.log('    │ Agent    │ ETH          │ AGENT Token  │ XRP          │ Channels     │');
    console.log('    ├──────────┼──────────────┼──────────────┼──────────────┼──────────────┤');

    for (const agent of this.agents) {
      try {
        const balances = (await httpGet(`${agent.httpUrl}/balances`)) as {
          ethBalance: string | null;
          agentTokenBalance: string | null;
          xrpBalance: string | null;
          evmChannels: Array<{
            channelId: string;
            peerAddress: string;
            deposit: string;
            transferredAmount: string;
            status: string;
          }>;
          xrpChannels: Array<{
            channelId: string;
            balance: string;
            status: string;
          }>;
        };

        const eth = balances.ethBalance ? parseFloat(balances.ethBalance).toFixed(4) : 'N/A';
        const token = balances.agentTokenBalance
          ? parseFloat(balances.agentTokenBalance).toFixed(2)
          : 'N/A';
        const xrp = balances.xrpBalance ? parseFloat(balances.xrpBalance).toFixed(2) : 'N/A';
        const evmCh = balances.evmChannels?.length || 0;
        const xrpCh = balances.xrpChannels?.length || 0;

        console.log(
          `    │ ${agent.agentId.padEnd(8)} │ ${eth.padStart(12)} │ ${token.padStart(12)} │ ${xrp.padStart(12)} │ ${`${evmCh} EVM, ${xrpCh} XRP`.padStart(12)} │`
        );

        // Print channel details
        for (const ch of balances.evmChannels || []) {
          const peerShort = ch.peerAddress.slice(0, 10) + '...';
          console.log(
            `    │          │  EVM: ${ch.status.padEnd(8)} dep=${ch.deposit.padStart(8)} sent=${ch.transferredAmount.padStart(8)} to ${peerShort}`
          );
        }
        for (const ch of balances.xrpChannels || []) {
          console.log(
            `    │          │  XRP: ${ch.status.padEnd(8)} bal=${ch.balance.padStart(10)}`
          );
        }
      } catch (error) {
        console.log(
          `    │ ${agent.agentId.padEnd(8)} │ Error: ${(error as Error).message.slice(0, 50)}`
        );
      }
    }

    console.log('    └──────────┴──────────────┴──────────────┴──────────────┴──────────────┘');
    console.log('');

    return `Reported balances for ${this.agents.length} agents`;
  }

  /**
   * Make a JSON-RPC request to rippled
   */
  private async xrplRpcRequest(method: string, params: Record<string, unknown>): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const urlObj = new URL(this.config.xrplRpcUrl);
      const data = JSON.stringify({
        method,
        params: [params],
      });

      const req = http.request(
        {
          hostname: urlObj.hostname,
          port: urlObj.port,
          path: urlObj.pathname,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(data),
          },
        },
        (res) => {
          let responseData = '';
          res.on('data', (chunk) => (responseData += chunk));
          res.on('end', () => {
            try {
              const parsed = JSON.parse(responseData);
              if (parsed.result?.error) {
                reject(new Error(parsed.result.error_message || parsed.result.error));
              } else {
                resolve(parsed);
              }
            } catch {
              resolve(responseData);
            }
          });
        }
      );

      req.on('error', reject);
      req.setTimeout(30000, () => {
        req.destroy();
        reject(new Error('XRPL RPC request timeout'));
      });
      req.write(data);
      req.end();
    });
  }

  // ============================================
  // Results Printing
  // ============================================

  private printResults(): void {
    console.log('\n========================================');
    console.log('Test Results');
    console.log('========================================\n');

    for (const phase of this.results.phases) {
      const icon = phase.success ? '✓' : '✗';
      console.log(`${icon} ${phase.name}: ${phase.details} (${phase.duration}ms)`);
    }

    console.log('');
    console.log(`Overall: ${this.results.success ? 'PASSED' : 'FAILED'}`);
    console.log(`Summary: ${this.results.summary}`);
    console.log('');
  }
}

// ============================================
// Main Entry Point
// ============================================

async function main(): Promise<void> {
  const runner = new DockerAgentTestRunner();
  const results = await runner.run();

  // Exit with appropriate code
  process.exit(results.success ? 0 : 1);
}

main().catch((err) => {
  console.error('Test runner error:', err);
  process.exit(1);
});
